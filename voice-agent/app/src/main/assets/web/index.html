<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'><rect width='32' height='32' fill='%236366f1' rx='6'/><text x='16' y='22' font-size='18' text-anchor='middle' fill='white'>V</text></svg>" />
  <title>Voice Agent</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 560px;
      margin: 0 auto;
      padding: 1rem;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
    }
    h1 { font-size: 1.25rem; margin-bottom: 0.5rem; }
    .status { font-size: 0.875rem; color: #888; margin-bottom: 1rem; }
    .status.active { color: #4ade80; }
    .status.error { color: #f87171; }
    .transcript {
      background: #16213e;
      border-radius: 8px;
      padding: 1rem;
      min-height: 200px;
      max-height: 50vh;
      overflow-y: auto;
      margin-bottom: 1rem;
    }
    .transcript:empty::before { content: "Transcript will appear here…"; color: #666; }
    .line { margin-bottom: 0.5rem; }
    .line.user { color: #93c5fd; }
    .line.model { color: #86efac; }
    .line .label { font-size: 0.7rem; text-transform: uppercase; opacity: 0.8; margin-right: 0.5rem; }
    button {
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      width: 100%;
      max-width: 280px;
      display: block;
      margin: 0 auto;
    }
    button.primary { background: #6366f1; color: white; }
    button.primary:hover { background: #4f46e5; }
    button.stop { background: #dc2626; color: white; }
    button.stop:hover { background: #b91c1c; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .error-msg { background: #450a0a; color: #fca5a5; padding: 0.75rem; border-radius: 8px; margin-top: 1rem; font-size: 0.875rem; }
    .config-warning { background: #422006; color: #fcd34d; padding: 0.75rem; border-radius: 8px; margin-bottom: 1rem; font-size: 0.875rem; }
    .mic-meter { margin: 0.75rem 0; padding: 0.5rem; background: #0f172a; border-radius: 8px; }
    .mic-meter .label { font-size: 0.7rem; color: #94a3b8; margin-bottom: 0.25rem; }
    .mic-meter .bar-wrap { height: 12px; background: #1e293b; border-radius: 6px; overflow: hidden; }
    .mic-meter .bar { height: 100%; background: linear-gradient(90deg, #22c55e, #eab308); border-radius: 6px; width: 0%; transition: width 0.05s; }
    .mic-meter .bar.speaking { background: #22c55e; }
    .mic-meter .value { font-size: 0.7rem; color: #64748b; margin-top: 0.25rem; font-family: monospace; }
    .mic-select-wrap { margin-bottom: 1rem; }
    .mic-select-wrap label { display: block; font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.35rem; }
    .mic-select-wrap select { width: 100%; max-width: 360px; padding: 0.5rem; font-size: 0.875rem; background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 6px; }
    .mic-select-wrap button { margin-left: 0.5rem; padding: 0.35rem 0.6rem; font-size: 0.75rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer; }
    .mic-select-wrap button:hover { background: #475569; }
    .screen-layer { border: 1px solid #334155; }
    .screen-detail { margin-top: 0.5rem; }
    .screen-detail summary { cursor: pointer; color: #e2e8f0; font-size: 0.85rem; }
    .screen-content { margin-top: 0.25rem; padding-left: 0.25rem; color: #94a3b8; font-size: 0.8rem; white-space: pre-wrap; word-break: break-word; }
    .screen-project-name { cursor: pointer; text-decoration: underline; text-decoration-style: dotted; }
    .screen-project-name:hover { color: #e2e8f0; }
    .framework-panel { margin-bottom: 1rem; padding: 0.75rem; background: #0f172a; border-radius: 8px; border: 1px solid #334155; }
    .framework-panel summary { cursor: pointer; color: #e2e8f0; font-size: 0.9rem; }
    .framework-panel textarea { width: 100%; min-height: 280px; margin-top: 0.5rem; padding: 0.5rem; font-size: 0.8rem; font-family: inherit; background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 6px; resize: vertical; box-sizing: border-box; }
    .framework-actions { margin-top: 0.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .framework-actions button { padding: 0.35rem 0.75rem; font-size: 0.8rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer; }
    .framework-actions button:hover { background: #475569; }
    .framework-actions button.primary { background: #6366f1; color: white; }
    .framework-actions button.primary:hover { background: #4f46e5; }
    .refinement-list { list-style: none; padding: 0; margin: 0; }
    .refinement-item { padding: 0.5rem 0; border-bottom: 1px solid #1e293b; }
    .refinement-item:last-child { border-bottom: none; }
    .refinement-meta { font-size: 0.7rem; color: #64748b; margin-bottom: 0.15rem; }
    .refinement-meta .source-badge { display: inline-block; padding: 0.05rem 0.35rem; border-radius: 3px; font-size: 0.65rem; font-weight: 600; text-transform: uppercase; margin-left: 0.35rem; }
    .refinement-meta .source-voice { background: #1e3a5f; color: #7dd3fc; }
    .refinement-meta .source-worker { background: #3b1f5e; color: #c4b5fd; }
    .refinement-meta .source-manual { background: #1c3829; color: #86efac; }
    .refinement-summary { font-size: 0.8rem; color: #cbd5e1; white-space: pre-wrap; word-break: break-word; }
    .refinement-fields { font-size: 0.7rem; color: #475569; margin-top: 0.15rem; font-style: italic; }
    .refinement-actions { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.5rem; }
    .refinement-actions button { padding: 0.3rem 0.6rem; font-size: 0.75rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer; }
    .refinement-actions button:hover { background: #475569; }
    .refinement-actions button.dl-btn { background: #065f46; color: #a7f3d0; }
    .refinement-actions button.dl-btn:hover { background: #047857; }
    .refinement-count { font-size: 0.75rem; color: #64748b; margin-left: 0.35rem; font-weight: normal; }
    .add-refinement-wrap { margin-top: 0.5rem; }
    .add-refinement-wrap textarea { width: 100%; min-height: 50px; padding: 0.4rem; font-size: 0.8rem; font-family: inherit; background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 6px; resize: vertical; box-sizing: border-box; }
    .screen-detail .screen-content > div { margin-bottom: 0.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid #1e293b; white-space: pre-wrap; word-break: break-word; font-size: 0.8rem; color: #94a3b8; }
    .screen-detail .screen-content > div:last-child { border-bottom: none; margin-bottom: 0; }
    .screen-detail .screen-content > div:empty { display: none; margin: 0; padding: 0; border: none; }
    .agent-tracker { margin-top: 0.75rem; }
    .agent-tracker-title { font-size: 0.85rem; color: #e2e8f0; margin-bottom: 0.4rem; display: flex; align-items: center; gap: 0.4rem; }
    .agent-tracker-title .active-dot { display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: #facc15; animation: agent-pulse 1.2s ease-in-out infinite; }
    @keyframes agent-pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
    @keyframes agent-spin { to { transform: rotate(360deg); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .agent-card { background: #1e293b; border: 1px solid #334155; border-radius: 6px; padding: 0.5rem 0.65rem; margin-bottom: 0.4rem; }
    .agent-card-header { display: flex; align-items: center; gap: 0.5rem; }
    .agent-card-name { font-size: 0.8rem; color: #e2e8f0; font-weight: 600; flex: 1; }
    .agent-status-badge { display: inline-flex; align-items: center; gap: 0.25rem; font-size: 0.7rem; font-weight: 600; padding: 0.1rem 0.4rem; border-radius: 4px; text-transform: uppercase; white-space: nowrap; }
    .agent-status-badge.pending { background: #1e293b; color: #94a3b8; border: 1px solid #475569; }
    .agent-status-badge.running { background: #422006; color: #fbbf24; border: 1px solid #92400e; }
    .agent-status-badge.running .spinner { display: inline-block; width: 10px; height: 10px; border: 2px solid #fbbf2466; border-top-color: #fbbf24; border-radius: 50%; animation: agent-spin 0.8s linear infinite; }
    .agent-status-badge.completed { background: #052e16; color: #4ade80; border: 1px solid #166534; }
    .agent-status-badge.failed { background: #450a0a; color: #f87171; border: 1px solid #991b1b; }
    .agent-card-time { font-size: 0.65rem; color: #64748b; margin-top: 0.2rem; }
    .agent-card-toggle { font-size: 0.7rem; color: #818cf8; cursor: pointer; background: none; border: none; padding: 0.15rem 0; margin-top: 0.25rem; text-decoration: underline; text-decoration-style: dotted; }
    .agent-card-toggle:hover { color: #a5b4fc; }
    .agent-card-body { margin-top: 0.35rem; padding: 0.4rem; background: #0f172a; border-radius: 4px; font-size: 0.75rem; color: #cbd5e1; white-space: pre-wrap; word-break: break-word; max-height: 300px; overflow-y: auto; display: none; }
    .agent-card-body.open { display: block; }
    .agent-card-summary { font-size: 0.75rem; color: #94a3b8; margin-top: 0.2rem; }

    /* ====== Mobile Tab Layout ====== */
    .tab-bar {
      display: flex;
      background: #0f172a;
      border-radius: 12px;
      padding: 3px;
      margin-bottom: 0.75rem;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .tab-bar button {
      flex: 1;
      padding: 0.65rem 0.25rem;
      font-size: 0.85rem;
      font-weight: 600;
      background: transparent;
      color: #64748b;
      border: none;
      border-radius: 9px;
      cursor: pointer;
      transition: background 0.2s, color 0.2s;
      max-width: none;
      width: auto;
      margin: 0;
      min-height: 40px;
    }
    .tab-bar button.active {
      background: #1e293b;
      color: #e2e8f0;
    }
    .tab-bar .tab-badge {
      display: inline-block;
      width: 6px; height: 6px;
      border-radius: 50%;
      background: #4ade80;
      margin-left: 4px;
      vertical-align: middle;
    }

    /* View switching via data-view on body */
    body[data-view="chat"] .view-project,
    body[data-view="chat"] .view-tools { display: none !important; }
    body[data-view="project"] .view-chat,
    body[data-view="project"] .view-tools { display: none !important; }
    body[data-view="tools"] .view-chat,
    body[data-view="tools"] .view-project { display: none !important; }

    /* Fixed bottom action bar */
    .bottom-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(26, 26, 46, 0.96);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-top: 1px solid #334155;
      padding: 0.6rem 1rem;
      padding-bottom: max(0.6rem, env(safe-area-inset-bottom));
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      align-items: center;
      z-index: 200;
    }
    .bottom-bar button {
      width: auto;
      max-width: none;
      margin: 0;
      flex: 1;
      min-height: 48px;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 12px;
      padding: 0.65rem 1rem;
    }
    .bottom-bar button.primary { max-width: 240px; }
    .bottom-bar button.stop { max-width: 240px; }
    .bottom-bar #btnNewIdea,
    .bottom-bar #btnDoneSpeaking {
      background: #334155;
      color: #e2e8f0;
      border: none;
      max-width: 180px;
    }
    .bottom-bar #btnNewIdea:hover,
    .bottom-bar #btnDoneSpeaking:hover { background: #475569; }

    /* Bottom padding so content isn't hidden behind fixed bar */
    body { padding-bottom: 5.5rem; }

    /* Mobile responsive */
    @media (max-width: 600px) {
      body { padding: 0.75rem 0.75rem 5.5rem; }
      h1 { font-size: 1.1rem; margin-bottom: 0.25rem; }
      .status { font-size: 0.8rem; margin-bottom: 0.5rem; }
      .transcript {
        min-height: 120px;
        max-height: calc(100vh - 13rem);
        font-size: 0.85rem;
        padding: 0.75rem;
      }
      .screen-detail summary {
        padding: 0.5rem 0;
        font-size: 0.9rem;
        min-height: 44px;
        display: flex;
        align-items: center;
      }
      .framework-panel textarea { min-height: 200px; }
      .mic-select-wrap select { max-width: 100%; }
      .screen-layer { padding: 0.75rem; font-size: 0.85rem; }
      .agent-card { padding: 0.5rem; }
      .refinement-actions button,
      .framework-actions button,
      .worker-btn { min-height: 40px; }
    }
  </style>
</head>
<body data-view="chat">
  <h1>Voice Agent</h1>
  <p class="status" id="status">Ready. Set API key in config.js and start.</p>
  <span id="polisherStatus" style="display:none; margin-left:10px; padding:3px 8px; border-radius:4px; background:#2563eb; color:#fff; font-size:0.8em; animation: pulse 1.5s ease-in-out infinite;"></span>
  <div id="configWarning" class="config-warning" hidden>Create <code>config.js</code> from <code>config.example.js</code> and set <code>GEMINI_API_KEY</code>.</div>
  <nav class="tab-bar" id="tabBar">
    <button type="button" class="tab-btn active" data-tab="chat">Chat</button>
    <button type="button" class="tab-btn" data-tab="project">Project</button>
    <button type="button" class="tab-btn" data-tab="tools">Tools</button>
  </nav>
  <div class="mic-select-wrap view-tools">
    <label for="micSelect">Microphone</label>
    <select id="micSelect">
      <option value="">Default (browser choice)</option>
    </select>
    <button type="button" id="btnRefreshMic">Refresh list</button>
  </div>
  <div id="frameworkSection" class="framework-panel view-tools" style="display: none;">
    <details>
      <summary>Refinement framework (view / edit)</summary>
      <p style="font-size: 0.8rem; color: #94a3b8; margin-top: 0.35rem;">Phases, modules, and triggers that guide the conductor. Changes apply to new conversations.</p>
      <textarea id="frameworkText" placeholder="Load to fetch current framework…"></textarea>
      <div class="framework-actions">
        <button type="button" id="btnFrameworkLoad">Load</button>
        <button type="button" id="btnFrameworkSave" class="primary">Save</button>
      </div>
    </details>
  </div>
  <div id="projectsSection" class="view-project" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: #0f172a; border-radius: 8px;">
    <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 0.5rem;">Projects</div>
    <select id="projectsSelect" style="width: 100%; max-width: 360px; padding: 0.5rem; font-size: 0.875rem; background: #1e293b; color: #e2e8f0; border: 1px solid #334155; border-radius: 6px;">
      <option value="">— Select project —</option>
    </select>
    <div style="margin-top: 0.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
      <button type="button" id="btnRefreshProjects" style="padding: 0.35rem 0.6rem; font-size: 0.75rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer;">Refresh list</button>
      <button type="button" id="btnNewProject" style="padding: 0.35rem 0.6rem; font-size: 0.75rem; background: #065f46; color: #a7f3d0; border: none; border-radius: 6px; cursor: pointer;">+ New project</button>
    </div>
  </div>
  <div class="transcript view-chat" id="transcript"></div>
  <div id="screenLayer" class="screen-layer view-project" style="display: none; margin-bottom: 1rem; background: #0f172a; border-radius: 8px; padding: 1rem; font-size: 0.875rem;">
    <div style="font-weight: bold; margin-bottom: 0.25rem;">
      <span id="screenProjectName" class="screen-project-name" style="font-weight: bold; color: #e2e8f0; font-size: 1rem;" title="Click to edit name">—</span>
    </div>
    <div id="screenMeta" style="font-size: 0.75rem; color: #94a3b8; margin-bottom: 0.75rem; line-height: 1.5;">
      <span id="screenStatus">In Progress</span> · Phase <span id="screenPhaseNum">1</span>/7 ·
      Confidence: <span id="screenConfidence">—</span> ·
      <span id="screenTrackRigor">Personal / Light</span>
    </div>
    <div id="screenElevatorPitch" style="display: none; margin-bottom: 0.75rem; padding: 0.5rem 0.65rem; background: #1e293b; border-left: 3px solid #6366f1; border-radius: 4px; font-size: 0.8rem; color: #cbd5e1; font-style: italic;"></div>
    <div style="margin-bottom: 0.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
      <button type="button" id="btnStructureIdea" style="padding: 0.35rem 0.75rem; font-size: 0.8rem; background: #f59e0b; color: #1e293b; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Structure Idea</button>
      <button type="button" id="btnExportIdea" style="padding: 0.35rem 0.75rem; font-size: 0.8rem; background: #6366f1; color: white; border: none; border-radius: 6px; cursor: pointer;">Export Refined Idea (.md)</button>
      <button type="button" id="btnDownloadRefinements" class="dl-btn" style="padding: 0.35rem 0.75rem; font-size: 0.8rem;">Refinement History (.md)</button>
    </div>
    <details class="screen-detail" id="phaseFoundation"><summary>Phase 1: Foundation</summary>
      <div class="screen-content"><div id="screenSpark"></div><div id="screenProblemDef"></div><div id="screenSolutionOutline"></div><div id="screenMarketContext"></div></div>
    </details>
    <details class="screen-detail" id="phaseValidation"><summary>Phase 2: Validation</summary>
      <div class="screen-content"><div id="screenProblemVal"></div><div id="screenSolutionVal"></div><div id="screenMarketAnalysis"></div><div id="screenEthicalImpact"></div></div>
    </details>
    <details class="screen-detail" id="phaseFeasibility"><summary>Phase 3: Feasibility</summary>
      <div class="screen-content"><div id="screenProductReqs"></div><div id="screenArchitecture"></div><div id="screenUxDesign"></div><div id="screenTestPlanning"></div></div>
    </details>
    <details class="screen-detail" id="phaseViability"><summary>Phase 4: Viability</summary>
      <div class="screen-content"><div id="screenBusinessModel"></div><div id="screenLegalCompliance"></div><div id="screenSustainability"></div></div>
    </details>
    <details class="screen-detail" id="phaseGtm"><summary>Phase 5: Go-to-Market</summary>
      <div class="screen-content"><div id="screenBranding"></div><div id="screenMarketing"></div><div id="screenLaunchStrategy"></div></div>
    </details>
    <details class="screen-detail" id="phaseExecution"><summary>Phase 6: Execution</summary>
      <div class="screen-content"><div id="screenMetricsKPIs"></div><div id="screenRiskMgmt"></div></div>
    </details>
    <details class="screen-detail" id="phaseSynthesis"><summary>Phase 7: Synthesis</summary>
      <div class="screen-content"><div id="screenConfBreakdown"></div><div id="screenDecisionLog"></div><div id="screenLeanCanvas"></div><div id="screenHandoff"></div></div>
    </details>
    <details class="screen-detail"><summary>Open Questions &amp; Next Actions</summary><div id="screenQuestionsActions" class="screen-content">—</div></details>
    <div id="agentTracker" class="agent-tracker" style="display: none;">
      <div class="agent-tracker-title"><span id="agentTrackerDot" class="active-dot" style="display: none;"></span> Agent Activity <span id="agentTrackerCount" style="font-size: 0.7rem; color: #64748b; font-weight: normal;"></span></div>
      <div id="agentCardList"></div>
    </div>
    <details class="screen-detail" id="refinementSection">
      <summary>Refinement History <span id="refinementCount" class="refinement-count"></span></summary>
      <div class="refinement-actions">
        <button type="button" id="btnRefreshRefinements">Refresh</button>
      </div>
      <ul id="refinementList" class="refinement-list screen-content">
        <li style="color: #64748b; font-size: 0.8rem;">No refinements yet.</li>
      </ul>
      <div class="add-refinement-wrap">
        <textarea id="manualRefinementText" placeholder="Add a manual note to the refinement history…"></textarea>
        <button type="button" id="btnAddRefinement" style="margin-top: 0.25rem; padding: 0.3rem 0.6rem; font-size: 0.75rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer;">Add note</button>
      </div>
    </details>
    <div id="workerButtons" style="margin-top: 0.75rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
      <button type="button" class="worker-btn" data-job="prdLite" style="padding: 0.35rem 0.75rem; font-size: 0.8rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer;">Run PRD-lite</button>
      <button type="button" class="worker-btn" data-job="competitorScan" style="padding: 0.35rem 0.75rem; font-size: 0.8rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer;">Run competitor scan</button>
      <button type="button" class="worker-btn" data-job="riskRegister" style="padding: 0.35rem 0.75rem; font-size: 0.8rem; background: #334155; color: #e2e8f0; border: none; border-radius: 6px; cursor: pointer;">Run risk register</button>
    </div>
    <details class="screen-detail" style="margin-top: 0.5rem;"><summary>Full registry</summary><pre id="screenRegistry" class="screen-content" style="white-space: pre-wrap; word-break: break-all; font-size: 0.7rem; margin-top: 0.25rem;"></pre></details>
  </div>
  <div id="micMeter" class="mic-meter view-chat" style="display: none;">
    <div class="label">Mic level</div>
    <div id="micDevice" class="value" style="margin-bottom: 0.25rem; color: #94a3b8;">Microphone: —</div>
    <div class="bar-wrap"><div id="micBar" class="bar" role="meter" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div></div>
    <div id="micValue" class="value">—</div>
  </div>
  <div class="bottom-bar" id="bottomBar">
    <button id="btnNewIdea" type="button" style="display: none;">New idea</button>
    <button id="btnStart" class="primary" type="button">Start</button>
    <button id="btnStop" class="stop" type="button" style="display: none;">Stop</button>
    <button id="btnDoneSpeaking" type="button" style="display: none;">Done speaking</button>
  </div>
  <div id="error" class="error-msg" hidden></div>
  <div id="debugPanel" class="view-tools" style="margin-top:1rem; padding:0.75rem; background:#0f172a; border-radius:8px; font-family:monospace; font-size:0.75rem; color:#94a3b8; max-height:260px; overflow-y:auto;">
    <div style="display:flex; justify-content:space-between; align-items:center; flex-wrap:wrap; gap:0.35rem;">
      <strong>Session log</strong>
      <div style="display:flex; gap:0.35rem; flex-wrap:wrap;">
        <select id="logFilter" style="padding:0.15rem 0.3rem; font-size:0.65rem; background:#1e293b; color:#e2e8f0; border:1px solid #334155; border-radius:4px;">
          <option value="">All</option>
          <option value="audio">Audio</option>
          <option value="echo">Echo</option>
          <option value="ws">WebSocket</option>
          <option value="agent">Agent</option>
          <option value="mic">Mic</option>
          <option value="state">State</option>
        </select>
        <button type="button" id="btnCopyDebug" style="padding:0.15rem 0.4rem; font-size:0.65rem; background:#334155; color:#e2e8f0; border:none; border-radius:4px; cursor:pointer;">Copy</button>
        <button type="button" id="btnDownloadLog" style="padding:0.15rem 0.4rem; font-size:0.65rem; background:#334155; color:#e2e8f0; border:none; border-radius:4px; cursor:pointer;">Download</button>
      </div>
    </div>
    <div id="debugStats" style="font-size:0.65rem; color:#64748b; margin-top:0.25rem;">Messages: 0 · Log entries: 0</div>
    <div id="debugLast" style="margin-top:0.5rem; white-space:pre-wrap; word-break:break-all;"></div>
  </div>

  <script>
    (function() {
      var tabBar = document.getElementById('tabBar');
      if (!tabBar) return;
      tabBar.addEventListener('click', function(e) {
        var btn = e.target.closest('.tab-btn');
        if (!btn) return;
        var view = btn.dataset.tab;
        document.body.setAttribute('data-view', view);
        tabBar.querySelectorAll('.tab-btn').forEach(function(b) { b.classList.remove('active'); });
        btn.classList.add('active');
      });
    })();
  </script>
  <script type="module">
    const LIVE_WS = 'wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1beta.GenerativeService.BidiGenerateContent';
    // Use a Live API–supported model. gemini-3.0-flash is not yet available for bidiGenerateContent.
const MODEL = 'gemini-2.5-flash-native-audio-preview-12-2025';
    const SEND_RATE = 16000;
    const RECV_RATE = 24000;
    const VERBOSE = true;

    let currentProjectId = null;
    let currentBackendUrl = null;
    let currentApiKey = null;

    function authFetch(url, opts = {}) {
      const headers = { ...(opts.headers || {}) };
      if (currentApiKey) headers['Authorization'] = 'Bearer ' + currentApiKey;
      return fetch(url, { ...opts, headers });
    }

    const pendingPatches = [];
    const MAX_PATCH_RETRIES = 3;

    function queueFailedPatch(projectId, patchBody, backendUrl) {
      pendingPatches.push({ projectId, patchBody, backendUrl, retries: 0 });
      updateSyncIndicator();
    }

    function updateSyncIndicator() {
      let el = document.getElementById('syncIndicator');
      if (!el) {
        el = document.createElement('div');
        el.id = 'syncIndicator';
        el.style.cssText = 'position:fixed;bottom:8px;right:8px;padding:4px 10px;background:#f59e0b;color:#000;border-radius:6px;font-size:12px;z-index:9999;display:none;';
        document.body.appendChild(el);
      }
      if (pendingPatches.length > 0) {
        el.textContent = 'Syncing... (' + pendingPatches.length + ')';
        el.style.display = 'block';
      } else {
        el.style.display = 'none';
      }
    }

    async function drainPatchQueue() {
      if (pendingPatches.length === 0) return;
      const toRetry = [...pendingPatches];
      pendingPatches.length = 0;
      for (const item of toRetry) {
        const base = (item.backendUrl || '').replace(/\/$/, '');
        if (!base) continue;
        try {
          const res = await authFetch(base + '/projects/' + encodeURIComponent(item.projectId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: item.patchBody,
          });
          if (res.ok) {
            log('Retry queue: patch succeeded for', item.projectId);
            const project = await res.json();
            updateScreenLayer(project);
          } else {
            item.retries++;
            if (item.retries < MAX_PATCH_RETRIES) pendingPatches.push(item);
            else log('Retry queue: giving up on patch after', MAX_PATCH_RETRIES, 'attempts');
          }
        } catch (e) {
          item.retries++;
          if (item.retries < MAX_PATCH_RETRIES) pendingPatches.push(item);
          else log('Retry queue: giving up on patch after error', e);
        }
      }
      updateSyncIndicator();
    }

    const HEALTH_TIMEOUT_MS = 3000;
    async function resolveBackendUrl(primary, fallback) {
      if (!primary) return fallback || '';
      const base = primary.replace(/\/$/, '');
      try {
        const r = await authFetch(base + '/health', { signal: AbortSignal.timeout(HEALTH_TIMEOUT_MS) });
        if (r.ok) { log('Primary backend reachable:', base); return primary; }
      } catch (_) {}
      if (fallback) {
        log('Primary backend unreachable, falling back to:', fallback);
        return fallback;
      }
      return primary;
    }

    const REGISTRY_PATCH_KEYS = ['projectId', 'switchToProjectName', 'createNewProject', 'name', 'snapshot', 'track', 'rigor', 'rigorOverrides', 'phase', 'backlog', 'risks', 'decisions', 'openQuestions', 'nextActions', 'checkpoint', 'constraints', 'mvp', 'nonGoals', 'validationPlan', 'buildPlan', 'moduleState', 'elevatorPitch', 'ideaConfidence', 'status', 'sessionCount', 'foundation', 'validation', 'feasibility', 'viability', 'goToMarket', 'execution', 'synthesis'];
    function extractJsonPatch(text) {
      if (!text || typeof text !== 'string') return null;
      const m = text.match(/---JSON---\s*([\s\S]*?)---JSON---/);
      if (!m) return null;
      const raw = m[1].trim();
      let parsed = null;
      try {
        parsed = JSON.parse(raw);
      } catch (_) {
        const objStart = raw.indexOf('{');
        if (objStart !== -1) {
          let depth = 0, end = -1;
          for (let i = objStart; i < raw.length; i++) {
            if (raw[i] === '{') depth++;
            else if (raw[i] === '}') { depth--; if (depth === 0) { end = i; break; } }
          }
            if (end !== -1) try { parsed = JSON.parse(raw.slice(objStart, end + 1)); } catch (_) {}
        }
      }
      if (!parsed || typeof parsed !== 'object') return null;
      const hasAnyKey = REGISTRY_PATCH_KEYS.some(k => Object.prototype.hasOwnProperty.call(parsed, k));
      return hasAnyKey ? parsed : null;
    }

    const dispatchedAgentSignatures = new Set();
    let lastAppliedPatchHash = '';

    function simplePatchHash(obj) {
      try { return JSON.stringify(obj); } catch (_) { return ''; }
    }

    function extractAgentDispatch(text) {
      if (!text || typeof text !== 'string') return null;
      const m = text.match(/---AGENT---\s*([\s\S]*?)---AGENT---/);
      if (!m) return null;
      const firstLine = m[1].trim().split('\n')[0].trim();
      if (!firstLine) return null;
      const pipeIdx = firstLine.indexOf('|');
      const agentId = (pipeIdx >= 0 ? firstLine.slice(0, pipeIdx).trim() : firstLine.trim());
      const taskDescription = pipeIdx >= 0 ? firstLine.slice(pipeIdx + 1).trim() : '';
      const normalizedSig = firstLine.toLowerCase().replace(/\s+/g, ' ').trim();
      return { agentId, taskDescription, signature: normalizedSig };
    }
    async function tryDispatchAgentTask(text, projectId, backendUrl) {
      const d = extractAgentDispatch(text);
      if (!d || !d.agentId || !projectId || !backendUrl) return;
      if (dispatchedAgentSignatures.has(d.signature)) return;
      dispatchedAgentSignatures.add(d.signature);
      const base = backendUrl.replace(/\/$/, '');
      try {
        const r = await authFetch(base + '/agents/tasks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ projectId, agentId: d.agentId, taskDescription: d.taskDescription }) });
        if (r.ok) {
          const taskData = await r.json();
          registerAgentTask(taskData.taskId, taskData.agentId, taskData.agentName || d.agentId);
          log.agent('Task dispatched', d.agentId, d.taskDescription?.slice(0, 40));
        } else { log.agent('Task dispatch failed', r.status); }
      } catch (e) { log.agent('Task dispatch error', e); }
    }

    function extractScreenText(text) {
      if (!text || typeof text !== 'string') return '';
      const m = text.match(/---SCREEN---\s*([\s\S]*?)---SCREEN---/);
      if (m) return m[1].trim().slice(0, 300);
      const speakM = text.match(/---SPEAK---\s*([\s\S]*?)---SPEAK---/);
      if (speakM) return speakM[1].trim().slice(0, 300);
      const clean = text.replace(/---JSON---[\s\S]*?---JSON---/g, '').replace(/---AGENT---[\s\S]*?---AGENT---/g, '').trim();
      return clean.slice(0, 300);
    }

    const NEW_PROJECT_INPUT_PHRASES = [
      /\bnew\s+(project|idea|phone|product|process|program|object)\b/i,
      /\bstart\s+(a\s+)?(new|fresh)\s+(project|idea|phone|product|one)\b/i,
      /\bstart\s+(a\s+)?fresh\b/i,
      /\bstart\s+something\s+new\b/i,
      /\bcreate\s+(a\s+)?new\b/i,
      /\bfresh\s+(project|idea)\b/i,
      /\bswitch\s+to\s+(a\s+)?new\b/i,
      /\bdifferent\s+(project|idea)\b/i,
    ];
    const NEW_PROJECT_MODEL_PHRASES = [
      /\bstarting\s+(a\s+)?new\s+project\b/i,
      /\bcreating\s+(a\s+)?new\s+project\b/i,
      /\bnew\s+project[\.\!,]\s*(what|tell|describe|share)/i,
      /\blet'?s\s+start\s+fresh\b/i,
      /\bbrand\s*new\s+project\b/i,
      /\bblank\s+project\b/i,
    ];
    let _newProjectDebounce = 0;
    function detectNewProjectVoiceCommand(inputText) {
      if (!inputText || !currentBackendUrl) return;
      const matched = NEW_PROJECT_INPUT_PHRASES.some(re => re.test(inputText));
      if (!matched) return;
      const now = Date.now();
      if (now - _newProjectDebounce < 15000) return;
      _newProjectDebounce = now;
      log('Voice command detected (user input): new project request');
      createNewProjectFromVoice();
    }
    function detectNewProjectFromModelOutput(outputText) {
      if (!outputText || !currentBackendUrl) return;
      const matched = NEW_PROJECT_MODEL_PHRASES.some(re => re.test(outputText));
      if (!matched) return;
      const now = Date.now();
      if (now - _newProjectDebounce < 15000) return;
      _newProjectDebounce = now;
      log('Voice command detected (model output): new project request');
      createNewProjectFromVoice();
    }
    async function createNewProjectFromVoice() {
      if (!currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      try {
        const createRes = await authFetch(base + '/projects', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
        if (!createRes.ok) { log('Voice new project failed', createRes.status); return; }
        const proj = await createRes.json();
        currentProjectId = proj.projectId;
        localStorage.setItem('idearefinement_lastProjectId', proj.projectId);
        updateScreenLayer(proj);
        document.getElementById('screenLayer').style.display = 'block';
        loadAgentTrackerForProject(proj.projectId);
        await refreshProjectsList();
        syncProjectsSelectToCurrent();
        log('Voice: created new project', proj.projectId);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ clientContent: { turns: [{ role: 'user', parts: [{ text: '[System: User requested a new project via voice. New projectId is ' + proj.projectId + '. Acknowledge and ask for their new idea.]' }] }], turnComplete: true } }));
        }
      } catch (e) { log('Voice new project error', e); }
    }

    const NAME_PATTERNS = [
      /(?:named?|call(?:ed|ing)?|naming)\s+(?:it|this|the\s+project|this\s+project)\s+["']?([A-Z][A-Za-z0-9 ]{1,30}?)["']?\s*[\.\,\!\?]/i,
      /(?:project|idea)\s+(?:name\s+is|is\s+called|called)\s+["']?([A-Z][A-Za-z0-9 ]{1,30}?)["']?\s*[\.\,\!\?]/i,
      /let'?s\s+call\s+(?:it|this)\s+["']?([A-Z][A-Za-z0-9 ]{1,30}?)["']?\s*[\.\,\!\?]/i,
      /["']([A-Z][A-Za-z0-9 ]{1,30}?)["']\s+(?:and\s+saved|is\s+saved|has\s+been\s+saved)/i,
      /(?:named?|call(?:ed|ing)?)\s+(?:it|this|the\s+project)\s+["']?([A-Z][A-Za-z0-9 ]{1,30}?)["']?\s+and\b/i,
    ];
    const LAUNCH_AGENT_RE = /launching\s+agent\s*[:\-–]\s*(\w+)/gi;
    const AGENT_SPEECH_MAP = [
      { patterns: [/open[\s-]*source/i, /oss\s+scout/i, /github\s+search/i, /repos?\s+search/i], agentId: 'ossScout', description: 'Discover relevant open source projects' },
      { patterns: [/market\s+research/i, /competitor\s+(scan|analysis|search)/i, /market\s+(scan|analysis|trends)/i, /competitive\s+landscape/i], agentId: 'marketResearch', description: 'Find market trends and competitor landscape' },
      { patterns: [/\bPRD\b/i, /product\s+requirements/i, /requirements\s+summary/i, /prd\s+summary/i], agentId: 'prdSummary', description: 'Generate product requirements summary' },
      { patterns: [/risk\s+register/i, /risk\s+analysis/i, /risks?\s+and\s+mitigations?/i], agentId: 'riskRegister', description: 'Suggest risks and mitigations' },
    ];
    const VALID_AGENT_IDS = new Set(['ossScout', 'marketResearch', 'prdSummary', 'riskRegister']);
    let _lastExtractedName = '';

    async function tryExtractFromSpeech(fullText, projectId, backendUrl) {
      if (!fullText || !projectId || !backendUrl) return;
      const base = backendUrl.replace(/\/$/, '');
      const patch = {};

      for (const re of NAME_PATTERNS) {
        const m = fullText.match(re);
        if (m && m[1]) {
          const name = m[1].trim();
          if (name.length >= 2 && name !== _lastExtractedName) {
            patch.name = name;
            _lastExtractedName = name;
            log('Speech extraction: project name =', name);
          }
          break;
        }
      }

      if (Object.keys(patch).length > 0) {
        try {
          patch._refinementNote = 'Auto-extracted from voice conversation';
          patch._refinementSource = 'voice';
          const res = await authFetch(base + '/projects/' + encodeURIComponent(projectId), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(patch) });
          if (res.ok) {
            const project = await res.json();
            updateScreenLayer(project);
            await refreshProjectsList();
            syncProjectsSelectToCurrent();
            log('Speech extraction: patched project', projectId);
          }
        } catch (e) { log('Speech extraction patch error', e); }
      }

      const agentsToDispatch = new Set();
      let m;
      const launchRe = new RegExp(LAUNCH_AGENT_RE.source, LAUNCH_AGENT_RE.flags);
      while ((m = launchRe.exec(fullText)) !== null) {
        const spoken = m[1].trim();
        const matched = [...VALID_AGENT_IDS].find(id => id.toLowerCase() === spoken.toLowerCase());
        if (matched) {
          agentsToDispatch.add(matched);
          log('Speech extraction: trigger phrase "Launching agent: ' + matched + '"');
        }
      }
      for (const agent of AGENT_SPEECH_MAP) {
        const mentioned = agent.patterns.some(re => re.test(fullText));
        if (mentioned) agentsToDispatch.add(agent.agentId);
      }
      for (const agentId of agentsToDispatch) {
        const sig = agentId + ':' + projectId;
        if (dispatchedAgentSignatures.has(sig)) continue;
        dispatchedAgentSignatures.add(sig);
        const agentInfo = AGENT_SPEECH_MAP.find(a => a.agentId === agentId);
        const desc = agentInfo?.description || 'Agent task';
        const displayName = agentInfo?.agentId || agentId;
        log('Speech extraction: dispatching agent', agentId);
        try {
          const r = await authFetch(base + '/agents/tasks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ projectId, agentId, taskDescription: desc }) });
          if (r.ok) {
            const taskData = await r.json();
            registerAgentTask(taskData.taskId, taskData.agentId, taskData.agentName || displayName);
            log.agent('Speech: dispatched', agentId);
          } else { log.agent('Speech: dispatch failed', r.status); }
        } catch (e) { log.agent('Speech: dispatch error', e); }
      }
    }

    /* ── Section content extraction: captures model's spoken analysis into phase fields ── */
    const SECTION_NUMBER_MAP = {
      '1.1': 'foundation.spark', '1.2': 'foundation.problemDefinition',
      '1.3': 'foundation.solutionOutline', '1.4': 'foundation.marketContext',
      '2.1': 'validation.problemValidation', '2.2': 'validation.solutionValidation',
      '2.3': 'validation.marketAnalysis', '2.4': 'validation.ethicalImpact',
      '3.1': 'feasibility.productRequirements', '3.2': 'feasibility.architecture',
      '3.3': 'feasibility.uxDesign', '3.4': 'feasibility.testPlanning',
      '4.1': 'viability.businessModel', '4.2': 'viability.legalCompliance',
      '4.3': 'viability.sustainability',
      '5.1': 'goToMarket.branding', '5.2': 'goToMarket.marketing',
      '5.3': 'goToMarket.launchStrategy',
      '6.1': 'execution.metricsKPIs', '6.2': 'execution.riskManagement',
      '7.1': 'synthesis.confidenceBreakdown', '7.2': 'synthesis.handoffChecklist',
    };
    const SECTION_KEYWORD_MAP = [
      { re: /(?:the\s+)?spark|origin\s+of.*idea|inspiration|where.*idea\s+come|how.*idea\s+start/i, field: 'foundation.spark' },
      { re: /problem\s+(?:definition|statement)|five\s+whys|root\s+(?:problem|cause)|target\s+audience|who.*(?:for|serve|help)/i, field: 'foundation.problemDefinition' },
      { re: /solution\s+outline|core\s+solution|(?:main|key)\s+(?:feature|benefit)|how.*(?:solve|work|address)/i, field: 'foundation.solutionOutline' },
      { re: /market\s+context|competitor|competitive\s+landscape|market\s+trend/i, field: 'foundation.marketContext' },
      { re: /problem\s+validation|evidence|pain\s+(?:point|score)|current\s+alternative/i, field: 'validation.problemValidation' },
      { re: /solution\s+validation|unique\s+value|UVP|key\s+assumption|differentiat/i, field: 'validation.solutionValidation' },
      { re: /market\s+analysis|ideal\s+customer|customer\s+(?:profile|segment)|ICP|TAM|SAM|SOM/i, field: 'validation.marketAnalysis' },
      { re: /ethical\s+(?:impact|consideration)|privacy\s+concern|data\s+ethics/i, field: 'validation.ethicalImpact' },
      { re: /product\s+requirements?|MVP\s+(?:scope|feature)|MoSCoW|must[\s-]have|acceptance\s+criteria/i, field: 'feasibility.productRequirements' },
      { re: /architecture|(?:recommended|tech)\s+stack|(?:backend|frontend)\s+(?:framework|technology)|API\s+(?:design|spec)/i, field: 'feasibility.architecture' },
      { re: /UX\s+design|user\s+(?:flow|journey|experience)|wireframe|onboarding\s+flow|accessibility/i, field: 'feasibility.uxDesign' },
      { re: /test\s+(?:planning|strategy)|quality\s+(?:metric|assurance)|QA\s+plan/i, field: 'feasibility.testPlanning' },
      { re: /business\s+model|revenue\s+(?:model|stream)|pricing|monetiz|unit\s+economics|break[\s-]even/i, field: 'viability.businessModel' },
      { re: /legal\s+(?:compliance|requirement)|regulatory|intellectual\s+property|IP\s+(?:protection|assessment)/i, field: 'viability.legalCompliance' },
      { re: /sustainability|social\s+impact|environmental/i, field: 'viability.sustainability' },
      { re: /brand(?:ing|\s+identity)|tagline|visual\s+(?:direction|identity)|tone\s+of\s+voice/i, field: 'goToMarket.branding' },
      { re: /marketing\s+(?:channel|strategy|plan)|retention|growth\s+(?:hack|strategy)|social\s+proof/i, field: 'goToMarket.marketing' },
      { re: /launch\s+(?:strategy|plan)|pre[\s-]launch|go[\s-]to[\s-]market|launch\s+type/i, field: 'goToMarket.launchStrategy' },
      { re: /(?:key\s+)?metrics|KPIs?|north\s+star\s+metric|success\s+(?:metric|measure)/i, field: 'execution.metricsKPIs' },
      { re: /risk\s+(?:management|register|assessment)|kill\s+criteria|mitigation/i, field: 'execution.riskManagement' },
      { re: /confidence\s+(?:breakdown|score|assessment)/i, field: 'synthesis.confidenceBreakdown' },
      { re: /decision\s+log|key\s+decisions?\s+made/i, field: 'synthesis.decisionLog' },
      { re: /lean\s+canvas/i, field: 'synthesis.leanCanvas' },
      { re: /handoff\s+(?:checklist|document)|deliverable|artifact/i, field: 'synthesis.handoffChecklist' },
    ];

    function identifySectionField(headerText) {
      const numMatch = headerText.match(/\((\d\.\d)\)/);
      if (numMatch && SECTION_NUMBER_MAP[numMatch[1]]) return SECTION_NUMBER_MAP[numMatch[1]];
      const inlineNum = headerText.match(/\b(\d\.\d)\b/);
      if (inlineNum && SECTION_NUMBER_MAP[inlineNum[1]]) return SECTION_NUMBER_MAP[inlineNum[1]];
      for (const entry of SECTION_KEYWORD_MAP) {
        if (entry.re.test(headerText)) return entry.field;
      }
      return null;
    }

    function buildNestedPatch(fieldPath, value) {
      const [phase, sub] = fieldPath.split('.');
      if (!sub) return { [phase]: value };
      return { [phase]: { [sub]: value } };
    }

    let _lastSectionExtractHash = '';

    const TRAILING_QUESTION_RE = /[.!]?\s*(?:(?:can|could|would|should|do|did|is|are|what|how|why|where|when|tell|let|have)\s.{5,}\?)\s*$/i;

    function filterConversationalContent(text) {
      let t = text.replace(TRAILING_QUESTION_RE, '').trim();
      if (t.length > 0 && !/[.!?]$/.test(t)) {
        const lastSentenceEnd = Math.max(t.lastIndexOf('. '), t.lastIndexOf('! '), t.lastIndexOf('? '));
        if (lastSentenceEnd > 20) {
          t = t.slice(0, lastSentenceEnd + 1).trim();
        }
      }
      return t;
    }

    function setNestedField(patch, fieldPath, value) {
      const [phase, sub] = fieldPath.split('.');
      if (sub) {
        if (!patch[phase]) patch[phase] = {};
        patch[phase][sub] = value;
      } else {
        patch[phase] = value;
      }
    }

    function appendExistingContent(patch, project) {
      for (const [key, value] of Object.entries(patch)) {
        if (key.startsWith('_') || typeof value !== 'object' || value === null) continue;
        const existing = project[key];
        if (!existing || typeof existing !== 'object') continue;
        for (const [sub, subVal] of Object.entries(value)) {
          if (typeof subVal === 'string' && existing[sub] && typeof existing[sub] === 'string') {
            const isDuplicate = existing[sub].endsWith(subVal) || existing[sub] === subVal;
            if (isDuplicate) {
              delete value[sub];
            } else {
              patch[key][sub] = existing[sub] + '\n\n---\n\n' + subVal;
            }
          }
        }
        if (Object.keys(value).length === 0) delete patch[key];
      }
    }

    async function tryExtractSectionContent(rawTurnText, projectId, backendUrl) {
      if (!rawTurnText || !projectId || !backendUrl) return;
      const fullTurnText = stripMarkers(rawTurnText);
      if (fullTurnText.length < 40) return;
      const hash = fullTurnText.length + ':' + fullTurnText.slice(-50);
      if (hash === _lastSectionExtractHash) return;
      _lastSectionExtractHash = hash;
      const base = backendUrl.replace(/\/$/, '');

      /* Simple keyword-based extraction for real-time visual feedback.
         The DocumentPolisher LLM handles proper structuring after each phase. */
      let keywordField = null;
      if (fullTurnText.length > 60) {
        let bestScore = 0;
        for (const entry of SECTION_KEYWORD_MAP) {
          const km = fullTurnText.match(entry.re);
          if (km) {
            const score = km[0].length + (entry.field.includes('.') ? 2 : 0);
            if (score > bestScore) { bestScore = score; keywordField = entry.field; }
          }
        }
      }

      const mergedPatch = {};
      if (keywordField) {
        const filtered = filterConversationalContent(fullTurnText.trim());
        if (filtered.length >= 20) {
          setNestedField(mergedPatch, keywordField, filtered);
          log('Section extraction (keyword): → ' + keywordField);
        }
      }

      if (Object.keys(mergedPatch).length === 0) return;

      /* Fetch current project and APPEND to existing content instead of overwriting */
      try {
        const curRes = await authFetch(base + '/projects/' + encodeURIComponent(projectId));
        if (curRes.ok) appendExistingContent(mergedPatch, await curRes.json());
      } catch (_) { /* overwrite if fetch fails */ }

      mergedPatch._refinementNote = 'Auto-captured from voice analysis';
      mergedPatch._refinementSource = 'voice';
      try {
        const res = await authFetch(base + '/projects/' + encodeURIComponent(projectId), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(mergedPatch) });
        if (res.ok) {
          const project = await res.json();
          updateScreenLayer(project);
          await refreshProjectsList();
          syncProjectsSelectToCurrent();
          log('Section extraction: patched', Object.keys(mergedPatch).filter(k => !k.startsWith('_')).join(', '));
        }
      } catch (e) { log('Section extraction patch error', e); }
    }

    async function tryApplyRegistryPatch(text, projectId, backendUrl) {
      const patch = extractJsonPatch(text);
      if (!patch || !backendUrl) return;
      const hash = simplePatchHash(patch);
      if (hash && hash === lastAppliedPatchHash) return;
      const base = backendUrl.replace(/\/$/, '');
      try {
        if (patch.createNewProject) {
          const createRes = await authFetch(base + '/projects', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
          if (createRes.ok) {
            const proj = await createRes.json();
            currentProjectId = proj.projectId;
            localStorage.setItem('idearefinement_lastProjectId', proj.projectId);
            updateScreenLayer(proj);
            document.getElementById('screenLayer').style.display = 'block';
            loadAgentTrackerForProject(proj.projectId);
            await refreshProjectsList();
            syncProjectsSelectToCurrent();
            log('Voice: created new project', proj.projectId);
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ clientContent: { turns: [{ role: 'user', parts: [{ text: '[System: New project created. ProjectId is ' + proj.projectId + '. Ask the user for their new idea.]' }] }], turnComplete: true } }));
            }
          } else { log('Voice: new project creation failed', createRes.status); }
          return;
        }
        if (patch.switchToProjectName) {
          const r = await authFetch(base + '/projects');
          const list = r.ok ? await r.json() : [];
          const name = (patch.switchToProjectName + '').trim().toLowerCase();
          const found = list.find(p => (p.name || '').trim().toLowerCase() === name || (p.name || '').toLowerCase().includes(name) || name.includes((p.name || '').toLowerCase()));
          if (found) {
            await loadProjectIntoUI(found.projectId);
            await refreshProjectsList();
            syncProjectsSelectToCurrent();
            log('Switched to project by name:', found.name || found.projectId);
          }
        }
        if (!projectId) return;
        const patchForBackend = { ...patch };
        delete patchForBackend.switchToProjectName;
        delete patchForBackend.createNewProject;
        if (Object.keys(patchForBackend).length === 0) return;
        for (const [k, v] of Object.entries(patchForBackend)) {
          if (typeof v === 'string') {
            patchForBackend[k] = stripMarkers(v);
          } else if (v && typeof v === 'object' && !Array.isArray(v)) {
            for (const [sk, sv] of Object.entries(v)) {
              if (typeof sv === 'string') v[sk] = stripMarkers(sv);
            }
          }
        }
        const screenNote = extractScreenText(text);
        if (screenNote) patchForBackend._refinementNote = screenNote;
        patchForBackend._refinementSource = 'voice';
        const patchBodyStr = JSON.stringify(patchForBackend);
        const res = await authFetch(base + '/projects/' + encodeURIComponent(projectId), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: patchBodyStr });
        if (!res.ok) {
          log('Registry PATCH failed', res.status);
          queueFailedPatch(projectId, patchBodyStr, backendUrl);
          return;
        }
        lastAppliedPatchHash = hash;
        const project = await res.json();
        updateScreenLayer(project);
        await refreshProjectsList();
        syncProjectsSelectToCurrent();
        log('Registry updated, projectId=', projectId);

        const newPhase = patchForBackend.phase != null ? patchForBackend.phase : (project.phase != null ? project.phase : null);
        if (newPhase != null && newPhase !== lastPolishedPhase) {
          log('Phase transition detected: ' + lastPolishedPhase + ' → ' + newPhase);
          lastPolishedPhase = newPhase;
          triggerDocumentPolisher(projectId, backendUrl, 'phase ' + newPhase);
        }
      } catch (e) {
        log('Registry PATCH error', e);
        try { queueFailedPatch(projectId, JSON.stringify(patchForBackend), backendUrl); } catch (_) {}
      }
    }

    function syncProjectsSelectToCurrent() {
      const select = document.getElementById('projectsSelect');
      if (select && currentProjectId) {
        select.value = currentProjectId;
      }
    }

    function renderRefinements(refinements) {
      const listEl = document.getElementById('refinementList');
      const countEl = document.getElementById('refinementCount');
      if (!listEl) return;
      const items = Array.isArray(refinements) ? refinements : [];
      if (countEl) countEl.textContent = items.length ? `(${items.length})` : '';
      if (items.length === 0) {
        listEl.innerHTML = '<li style="color: #64748b; font-size: 0.8rem;">No refinements yet.</li>';
        return;
      }
      const reversed = [...items].reverse();
      listEl.innerHTML = reversed.map(r => {
        const date = r.timestamp ? new Date(r.timestamp).toLocaleString() : '—';
        const src = r.source || 'voice';
        const badgeClass = src === 'worker' ? 'source-worker' : src === 'manual' ? 'source-manual' : 'source-voice';
        const fields = r.fieldsChanged && r.fieldsChanged !== r.summary
          ? `<div class="refinement-fields">${escHtml(r.fieldsChanged)}</div>` : '';
        return `<li class="refinement-item">
          <div class="refinement-meta">${escHtml(date)} · v${r.version ?? '?'} · Phase ${r.phase ?? '?'}<span class="source-badge ${badgeClass}">${escHtml(src)}</span></div>
          <div class="refinement-summary">${escHtml(r.summary || '(no summary)')}</div>
          ${fields}
        </li>`;
      }).join('');
    }

    function escHtml(s) {
      return (s || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    async function downloadRefinementsMd() {
      if (!currentProjectId || !currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      try {
        const r = await authFetch(base + '/projects/' + encodeURIComponent(currentProjectId) + '/refinements/download');
        if (!r.ok) { log('Download refinements failed', r.status); return; }
        const blob = await r.blob();
        const disposition = r.headers.get('Content-Disposition') || '';
        const fileMatch = disposition.match(/filename="?([^"]+)"?/);
        const filename = fileMatch ? fileMatch[1] : 'refinements.md';
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      } catch (e) { log('Download refinements error', e); }
    }

    async function addManualRefinement() {
      if (!currentProjectId || !currentBackendUrl) return;
      const ta = document.getElementById('manualRefinementText');
      if (!ta) return;
      const summary = ta.value.trim();
      if (!summary) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      try {
        const r = await authFetch(base + '/projects/' + encodeURIComponent(currentProjectId) + '/refinements', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ summary, source: 'manual' })
        });
        if (r.ok) {
          ta.value = '';
          const proj = await fetchProject(base, currentProjectId);
          if (proj) updateScreenLayer(proj);
        } else { log('Add refinement failed', r.status); }
      } catch (e) { log('Add refinement error', e); }
    }

    function updateScreenLayer(project) {
      const el = document.getElementById('screenLayer');
      if (!el) return;
      el.style.display = 'block';
      const nameEl = document.getElementById('screenProjectName');
      if (nameEl) {
        nameEl.textContent = (project.name || '').trim() || 'Click to add name';
        nameEl.dataset.projectId = project.projectId || '';
      }
      const set = (id, text) => { const e = document.getElementById(id); if (e) e.textContent = text || ''; };
      const setHtml = (id, text) => { const e = document.getElementById(id); if (e) e.innerHTML = text ? escHtml(text).replace(/\n/g, '<br>') : ''; };

      set('screenStatus', project.status || 'In Progress');
      set('screenPhaseNum', project.phase != null ? project.phase : '1');
      set('screenConfidence', project.ideaConfidence != null ? project.ideaConfidence + '%' : '—');
      const overrides = project.rigorOverrides ? ' | ' + project.rigorOverrides : '';
      set('screenTrackRigor', (project.track || 'Personal') + ' / ' + (project.rigor || 'Light') + overrides);

      const pitchEl = document.getElementById('screenElevatorPitch');
      if (pitchEl) {
        if (project.elevatorPitch) { pitchEl.textContent = project.elevatorPitch; pitchEl.style.display = 'block'; }
        else { pitchEl.style.display = 'none'; }
      }

      const f = project.foundation || {};
      setHtml('screenSpark', f.spark ? '**The Spark**\n' + f.spark : '');
      setHtml('screenProblemDef', f.problemDefinition ? '**Problem Definition**\n' + f.problemDefinition : '');
      setHtml('screenSolutionOutline', f.solutionOutline ? '**Solution Outline**\n' + f.solutionOutline : '');
      setHtml('screenMarketContext', f.marketContext ? '**Market Context**\n' + f.marketContext : '');
      const hasFoundation = f.spark || f.problemDefinition || f.solutionOutline || f.marketContext;
      const foundationEl = document.getElementById('phaseFoundation');
      if (foundationEl) { if (hasFoundation) foundationEl.open = true; }

      const v = project.validation || {};
      setHtml('screenProblemVal', v.problemValidation ? '**Problem Validation**\n' + v.problemValidation : '');
      setHtml('screenSolutionVal', v.solutionValidation ? '**Solution Validation & UVP**\n' + v.solutionValidation : '');
      setHtml('screenMarketAnalysis', v.marketAnalysis ? '**Market & Audience**\n' + v.marketAnalysis : '');
      setHtml('screenEthicalImpact', v.ethicalImpact ? '**Ethical Impact**\n' + v.ethicalImpact : '');

      const fe = project.feasibility || {};
      setHtml('screenProductReqs', fe.productRequirements ? '**Product Requirements**\n' + fe.productRequirements : '');
      setHtml('screenArchitecture', fe.architecture ? '**Architecture**\n' + fe.architecture : '');
      setHtml('screenUxDesign', fe.uxDesign ? '**UX/UI**\n' + fe.uxDesign : '');
      setHtml('screenTestPlanning', fe.testPlanning ? '**Test Planning**\n' + fe.testPlanning : '');

      const vi = project.viability || {};
      setHtml('screenBusinessModel', vi.businessModel ? '**Business Model**\n' + vi.businessModel : '');
      setHtml('screenLegalCompliance', vi.legalCompliance ? '**Legal & Compliance**\n' + vi.legalCompliance : '');
      setHtml('screenSustainability', vi.sustainability ? '**Sustainability**\n' + vi.sustainability : '');

      const gtm = project.goToMarket || {};
      setHtml('screenBranding', gtm.branding ? '**Branding**\n' + gtm.branding : '');
      setHtml('screenMarketing', gtm.marketing ? '**Marketing**\n' + gtm.marketing : '');
      setHtml('screenLaunchStrategy', gtm.launchStrategy ? '**Launch Strategy**\n' + gtm.launchStrategy : '');

      const ex = project.execution || {};
      setHtml('screenMetricsKPIs', ex.metricsKPIs ? '**Metrics & KPIs**\n' + ex.metricsKPIs : '');
      setHtml('screenRiskMgmt', ex.riskManagement ? '**Risk Management**\n' + ex.riskManagement : '');

      const sy = project.synthesis || {};
      setHtml('screenConfBreakdown', sy.confidenceBreakdown ? '**Confidence**\n' + sy.confidenceBreakdown : '');
      setHtml('screenDecisionLog', sy.decisionLog ? '**Decisions**\n' + sy.decisionLog : '');
      setHtml('screenLeanCanvas', sy.leanCanvas ? '**Lean Canvas**\n' + sy.leanCanvas : '');
      setHtml('screenHandoff', sy.handoffChecklist ? '**Handoff**\n' + sy.handoffChecklist : '');

      const q = (project.openQuestions || []);
      const a = (project.nextActions || []);
      const qaEl = document.getElementById('screenQuestionsActions');
      if (qaEl) qaEl.textContent = (q.length ? 'Open questions:\n' + q.map(x => typeof x === 'string' ? x : (x.text || JSON.stringify(x))).join('\n') + '\n\n' : '') + (a.length ? 'Next actions:\n' + a.map(x => typeof x === 'string' ? x : (x.text || JSON.stringify(x))).join('\n') : '') || '—';

      renderRefinements(project.refinements);
      const reg = document.getElementById('screenRegistry');
      if (reg) reg.textContent = JSON.stringify(project, null, 2);
    }

    async function fetchProject(backendUrl, projectId) {
      const base = (backendUrl || currentBackendUrl || '').replace(/\/$/, '');
      if (!base || !projectId) return null;
      try {
        const r = await authFetch(base + '/projects/' + encodeURIComponent(projectId));
        return r.ok ? await r.json() : null;
      } catch (_) { return null; }
    }

    async function showProjectsSection() {
      const el = document.getElementById('projectsSection');
      const frameworkEl = document.getElementById('frameworkSection');
      if (currentBackendUrl) {
        if (frameworkEl) frameworkEl.style.display = 'block';
        if (el) {
          el.style.display = 'block';
          await refreshProjectsList();
          syncProjectsSelectToCurrent();
        }
      }
    }

    async function loadFramework() {
      if (!currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const ta = document.getElementById('frameworkText');
      if (!ta) return;
      try {
        const r = await authFetch(base + '/framework');
        if (r.ok) ta.value = await r.text();
        else setStatus('Failed to load framework: ' + r.status, 'error');
      } catch (e) { log('Load framework failed', e); setStatus('Load framework failed', 'error'); }
    }

    async function saveFramework() {
      if (!currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const ta = document.getElementById('frameworkText');
      if (!ta) return;
      try {
        const r = await authFetch(base + '/framework', { method: 'PUT', headers: { 'Content-Type': 'text/plain' }, body: ta.value });
        if (r.ok) { setStatus('Framework saved.'); }
        else { const err = await r.json().catch(() => ({})); setStatus('Save failed: ' + (err.error || r.status), 'error'); }
      } catch (e) { log('Save framework failed', e); setStatus('Save failed', 'error'); }
    }

    async function refreshProjectsList() {
      if (!currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const select = document.getElementById('projectsSelect');
      if (!select) return;
      try {
        const r = await authFetch(base + '/projects');
        const list = r.ok ? await r.json() : [];
        select.innerHTML = '<option value="">— Select project —</option>';
        list.sort((a, b) => new Date(b.lastActiveAt || 0) - new Date(a.lastActiveAt || 0));
        list.forEach(p => {
          const opt = document.createElement('option');
          opt.value = p.projectId;
          const raw = (p.name || p.snapshot || '').trim();
          const label = raw || ('Untitled idea · ' + (p.projectId || '').slice(0, 8));
          opt.textContent = label.length > 60 ? label.slice(0, 60) + '…' : label;
          select.appendChild(opt);
        });
      } catch (e) { log('Refresh projects failed', e); }
    }

    async function loadProjectIntoUI(projectId) {
      if (!projectId || !currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const proj = await fetchProject(base, projectId);
      if (!proj) return;
      currentProjectId = projectId;
      localStorage.setItem('idearefinement_lastProjectId', projectId);
      updateScreenLayer(proj);
      document.getElementById('screenLayer').style.display = 'block';
      loadAgentTrackerForProject(projectId);
      setStatus('Switched to project. Click Start to resume.');
      log('Loaded project', projectId);
    }

    async function runWorker(jobType) {
      if (!currentProjectId || !currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const btn = document.querySelector('.worker-btn[data-job="' + jobType + '"]');
      if (btn) btn.disabled = true;
      try {
        const r = await authFetch(base + '/workers/' + jobType, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ projectId: currentProjectId, apply: true }) });
        if (!r.ok) { const err = await r.json().catch(() => ({})); throw new Error(err.error || r.statusText); }
        const data = await r.json();
        if (data.project) updateScreenLayer(data.project);
        log('Worker', jobType, 'done');
      } catch (e) { log('Worker failed', e); if (typeof setStatus === 'function') setStatus('Worker failed: ' + (e.message || e)); }
      if (btn) btn.disabled = false;
    }

    // ── Categorized session log ──────────────────────────────────────
    const LOG_BUFFER_MAX = 5000;
    const sessionLog = [];
    let _activeLogFilter = '';

    function log(...args) {
      if (!VERBOSE) return;
      _logEntry('general', ...args);
    }
    log.audio  = (...args) => { if (VERBOSE) _logEntry('audio', ...args); };
    log.echo   = (...args) => { if (VERBOSE) _logEntry('echo', ...args); };
    log.ws     = (...args) => { if (VERBOSE) _logEntry('ws', ...args); };
    log.agent  = (...args) => { if (VERBOSE) _logEntry('agent', ...args); };
    log.mic    = (...args) => { if (VERBOSE) _logEntry('mic', ...args); };
    log.state  = (...args) => { if (VERBOSE) _logEntry('state', ...args); };

    function _logEntry(cat, ...args) {
      const ts = new Date().toISOString();
      const parts = args.map(a => {
        if (a instanceof Error) return a.message;
        if (typeof a === 'object' && a !== null) {
          try { const s = JSON.stringify(a); return s.length > 500 ? s.slice(0, 500) + '…' : s; } catch (_) { return String(a); }
        }
        return String(a);
      });
      const msg = parts.join(' ');
      const entry = { ts, cat, msg };
      sessionLog.push(entry);
      if (sessionLog.length > LOG_BUFFER_MAX) sessionLog.splice(0, sessionLog.length - LOG_BUFFER_MAX);
      console.log(`[${cat.toUpperCase()}][${ts}]`, ...args);
      _renderLogPanel();
    }

    function _renderLogPanel() {
      const statsEl = document.getElementById('debugStats');
      const lastEl = document.getElementById('debugLast');
      if (!statsEl || !lastEl) return;
      const filter = _activeLogFilter;
      const filtered = filter ? sessionLog.filter(e => e.cat === filter) : sessionLog;
      const tail = filtered.slice(-30);
      statsEl.textContent = 'Log entries: ' + sessionLog.length + (filter ? ' (showing ' + filtered.length + ' "' + filter + '")' : '');
      lastEl.textContent = tail.map(e => '[' + e.cat.toUpperCase() + '] ' + e.ts.slice(11, 23) + ' ' + e.msg).join('\n');
      const panel = document.getElementById('debugPanel');
      if (panel) panel.scrollTop = panel.scrollHeight;
    }

    function _downloadSessionLog() {
      const text = sessionLog.map(e => `[${e.ts}] [${e.cat.toUpperCase()}] ${e.msg}`).join('\n');
      const blob = new Blob([text], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'session-log-' + new Date().toISOString().slice(0, 19).replace(/:/g, '-') + '.txt';
      a.click();
      URL.revokeObjectURL(url);
    }

    function logPayload(label, obj) {
      if (!VERBOSE) return;
      const s = JSON.stringify(obj);
      const truncated = s.length > 2000 ? s.slice(0, 2000) + '...[truncated ' + (s.length - 2000) + ' chars]' : s;
      log.ws(label, truncated);
    }

    log('Config:', { LIVE_WS, MODEL, SEND_RATE, RECV_RATE });

    async function refreshMicList(requestPermission = false) {
      const select = document.getElementById('micSelect');
      if (!select) return;
      const current = select.value;
      if (requestPermission) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach(t => t.stop());
        } catch (_) {}
      }
      let devices = [];
      try {
        devices = await navigator.mediaDevices.enumerateDevices();
      } catch (e) {
        log('enumerateDevices error', e);
        return;
      }
      const mics = devices.filter(d => d.kind === 'audioinput');
      select.innerHTML = '<option value="">Default (browser choice)</option>';
      mics.forEach((d, i) => {
        const opt = document.createElement('option');
        opt.value = d.deviceId;
        opt.textContent = d.label || ('Microphone ' + (i + 1));
        select.appendChild(opt);
      });
      if (current && mics.some(d => d.deviceId === current)) select.value = current;
    }

    await refreshMicList();
    document.getElementById('btnRefreshMic').addEventListener('click', () => refreshMicList(true));

    const statusEl = document.getElementById('status');
    const transcriptEl = document.getElementById('transcript');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const errorEl = document.getElementById('error');
    const configWarning = document.getElementById('configWarning');
    const debugStatsEl = document.getElementById('debugStats');
    const debugLastEl = document.getElementById('debugLast');

    const lastMessages = [];
    const MAX_LAST = 15;
    function stripForDebug(obj) {
      if (obj === null || obj === undefined) return obj;
      if (typeof obj === 'string' && obj.length > 100) return obj.slice(0, 100) + '...[len=' + obj.length + ']';
      if (Array.isArray(obj)) return obj.map(stripForDebug);
      if (typeof obj === 'object') {
        const out = {};
        for (const k of Object.keys(obj)) {
          const v = obj[k];
          if (k === 'data' && typeof v === 'string') out[k] = '[base64 len=' + v.length + ']';
          else out[k] = stripForDebug(v);
        }
        return out;
      }
      return obj;
    }
    function pushDebug(msgNum, msg) {
      lastMessages.push({ n: msgNum, keys: Object.keys(msg), payload: stripForDebug(msg) });
      if (lastMessages.length > MAX_LAST) lastMessages.shift();
    }

    function setStatus(text, className = '') {
      statusEl.textContent = text;
      statusEl.className = 'status ' + className;
    }
    function showError(msg) {
      errorEl.textContent = msg;
      errorEl.hidden = false;
      setStatus('Error', 'error');
    }
    function hideError() { errorEl.hidden = true; }
    function addTranscript(label, text) {
      const forUser = label === 'You';
      const cleaned = stripMarkers(stripSpeakerPrefix(text, forUser));
      if (!cleaned) return;
      const line = document.createElement('div');
      line.className = 'line ' + (forUser ? 'user' : 'model');
      line.innerHTML = '<span class="label">' + label + '</span>' + cleaned.replace(/</g, '&lt;').replace(/>/g, '&gt;');
      transcriptEl.appendChild(line);
      transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }
    function flushUserTranscript() {
      if (userFlushTimer) clearTimeout(userFlushTimer);
      userFlushTimer = null;
      if (userTranscriptBuffer.trim()) {
        const text = userTranscriptBuffer.trim();
        addTranscript('You', text);
        conversationLog.push({ speaker: 'user', text, at: new Date().toISOString() });
        userTranscriptBuffer = '';
      }
    }
    function flushModelTranscript() {
      if (modelFlushTimer) clearTimeout(modelFlushTimer);
      modelFlushTimer = null;
      if (modelTranscriptBuffer.trim()) {
        const text = modelTranscriptBuffer.trim();
        addTranscript('Model', text);
        conversationLog.push({ speaker: 'model', text, at: new Date().toISOString() });
        modelTranscriptBuffer = '';
        modelTurnCount++;
        if (modelTurnCount > 0 && modelTurnCount % POLISHER_EVERY_N_TURNS === 0 && currentProjectId && currentBackendUrl) {
          triggerDocumentPolisher(currentProjectId, currentBackendUrl, 'periodic (turn ' + modelTurnCount + ')');
        }
      }
    }
    function scheduleModelSpeakingEnd(_durationMs) {
      if (modelSpeakingEndTimer) clearTimeout(modelSpeakingEndTimer);
      const ctx = window.playbackCtx;
      const remainingMs = ctx
        ? Math.max(0, (nextPlaybackTime - ctx.currentTime) * 1000)
        : (_durationMs || 0);
      modelSpeakingEndTimer = setTimeout(() => {
        modelSpeakingEndTimer = null;
        modelIsSpeaking = false;
        lastModelSpeakingEndTime = Date.now();
        log.state('modelIsSpeaking = false (playback window ended), grace period started');
      }, remainingMs + 600);
    }

    let ws = null;
    let mediaStream = null;
    let audioContext = null;
    let processor = null;
    let setupDone = false;
    let userInitiatedClose = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 3;
    let lastConversationConfig = null;
    const micLevel = { rms: 0, speaking: false, ticks: 0, analyser: null };
    let micMeterInterval = null;
    /** Half-duplex: true while model audio is playing so we don't send mic and hear ourselves */
    let modelIsSpeaking = false;
    let modelSpeakingEndTimer = null;
    /** Transcript buffering: accumulate small chunks and flush as one line */
    let userTranscriptBuffer = '';
    let userFlushTimer = null;
    let modelTranscriptBuffer = '';
    let modelFlushTimer = null;
    let modelTurnTranscript = '';
    let sectionExtractTimer = null;
    const SECTION_EXTRACT_DEBOUNCE_MS = 3000;
    let conversationLog = [];
    let lastTranscriptSaveLen = 0;
    const TRANSCRIPT_FLUSH_MS = 700;
    let lastPolishedPhase = null;
    let polisherRunning = false;
    let modelTurnCount = 0;
    const POLISHER_EVERY_N_TURNS = 8;
    /** Ignore inputTranscription for this long after model output/audio (avoids attributing echoed model speech to user) */
    const ECHO_SUPPRESS_MS = 800;
    /** After model stops, brief mute so we don't send echo; then we only send when user is speaking (see send logic) */
    const POST_SPEECH_GRACE_MS = 500;
    /** Min length for content-based echo match (avoid suppressing short real user replies like "yes") */
    const ECHO_MATCH_MIN_LEN = 20;
    /** Keep this much recent model transcript for content-based echo detection across multiple model turns */
    const RECENT_MODEL_TRANSCRIPT_MAX = 1500;
    /** RMS threshold: if mic level is above this during grace period, treat as real user speech (not echo) */
    const ECHO_GATE_RMS_THRESHOLD = 0.02;
    /** Last time we received model output (outputTranscription or model audio); used to suppress echo in user transcript */
    let lastModelOutputTime = 0;
    /** When model speaking ended (playback window); used for POST_SPEECH_GRACE_MS */
    let lastModelSpeakingEndTime = 0;
    /** Rolling buffer of recent model speech for echo detection (so we don't attribute repeated/echoed model phrases to user) */
    let recentModelTranscript = '';
    /** Next scheduled start time for model audio (AudioContext time) so chunks play in order without overlapping */
    let nextPlaybackTime = 0;
    /** Agent tracker: maps taskId -> { taskId, agentId, agentName, status, createdAt, completedAt, result, summary } */
    const trackedAgentTasks = new Map();
    const deliveredTaskIds = new Set();
    let agentResultsPollInterval = null;
    const AGENT_RESULTS_POLL_MS = 5000;

    function mergeConsecutiveTranscript(entries) {
      if (!entries || entries.length === 0) return [];
      const merged = [];
      let current = { speaker: entries[0].speaker, text: entries[0].text };
      for (let i = 1; i < entries.length; i++) {
        if (entries[i].speaker === current.speaker) {
          const sep = current.text.match(/[.!?:,]$/) ? ' ' : ' ';
          current.text += sep + entries[i].text;
        } else {
          merged.push(current);
          current = { speaker: entries[i].speaker, text: entries[i].text };
        }
      }
      merged.push(current);
      return merged;
    }

    function formatTranscriptForPolisher() {
      if (conversationLog.length === 0) return '';
      const merged = mergeConsecutiveTranscript(conversationLog);
      return merged.map(e => (e.speaker === 'user' ? 'User' : 'Model') + ': ' + e.text).join('\n\n');
    }

    function buildReconnectContext() {
      if (conversationLog.length === 0) return null;
      const merged = mergeConsecutiveTranscript(conversationLog);
      const MAX_TURNS = 30;
      const recent = merged.length > MAX_TURNS ? merged.slice(-MAX_TURNS) : merged;
      let ctx = '[System: The WebSocket connection was interrupted and this is a NEW session. You MUST continue the conversation where it left off. DO NOT start over or re-introduce yourself. Here is the conversation history so far:]\n\n';
      for (const entry of recent) {
        ctx += (entry.speaker === 'user' ? 'User' : 'Model') + ': ' + entry.text + '\n\n';
      }
      ctx += '[System: Continue from where the conversation left off. Do NOT repeat questions already asked or topics already covered. Pick up naturally from the last exchange above.]';
      return ctx;
    }

    async function triggerDocumentPolisher(projectId, backendUrl, reason) {
      if (!projectId || !backendUrl) return;
      if (polisherRunning) {
        log('DocumentPolisher: skipped (already running), reason=' + reason);
        return;
      }
      const transcript = formatTranscriptForPolisher();
      if (transcript.length < 100) {
        log('DocumentPolisher: skipped (transcript too short: ' + transcript.length + ')');
        return;
      }
      polisherRunning = true;
      const base = backendUrl.replace(/\/$/, '');
      const statusEl = document.getElementById('polisherStatus');
      if (statusEl) {
        statusEl.textContent = 'Structuring data (' + reason + ')...';
        statusEl.style.display = 'inline';
      }
      log('DocumentPolisher: triggering, reason=' + reason + ', transcript=' + transcript.length + ' chars');
      try {
        flushUserTranscript();
        flushModelTranscript();
        if (conversationLog.length > lastTranscriptSaveLen) {
          await authFetch(base + '/projects/' + encodeURIComponent(projectId), {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ conversationTranscript: conversationLog, _refinementNote: 'transcript before polish', _refinementSource: 'voice' })
          });
          lastTranscriptSaveLen = conversationLog.length;
        }
        const res = await authFetch(base + '/projects/' + encodeURIComponent(projectId) + '/structure', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ transcript })
        });
        if (res.ok) {
          const project = await res.json();
          updateScreenLayer(project);
          await refreshProjectsList();
          syncProjectsSelectToCurrent();
          log('DocumentPolisher: success, reason=' + reason);
          if (statusEl) statusEl.textContent = 'Structured!';
          setTimeout(() => { if (statusEl) statusEl.style.display = 'none'; }, 3000);
        } else {
          log('DocumentPolisher: failed with status ' + res.status);
          if (statusEl) { statusEl.textContent = 'Structuring failed'; setTimeout(() => { statusEl.style.display = 'none'; }, 3000); }
        }
      } catch (e) {
        log('DocumentPolisher: error', e);
        if (statusEl) { statusEl.textContent = 'Structuring error'; setTimeout(() => { statusEl.style.display = 'none'; }, 3000); }
      } finally {
        polisherRunning = false;
      }
    }

    function formatAgentResultSummary(result) {
      if (result == null) return '(no result)';
      if (typeof result === 'string') return result.slice(0, 600);
      if (typeof result === 'object') {
        if (result.note) return result.note;
        if (result.prdLite) return String(result.prdLite).slice(0, 600);
        if (result.suggestedNextStep) return result.note ? result.note + '\n' + result.suggestedNextStep : result.suggestedNextStep;
        return JSON.stringify(result).slice(0, 600);
      }
      return String(result).slice(0, 600);
    }

    function formatAgentResultFull(result) {
      if (result == null) return '(no result)';
      if (typeof result === 'string') return result;
      if (typeof result === 'object') return JSON.stringify(result, null, 2);
      return String(result);
    }

    function registerAgentTask(taskId, agentId, agentName) {
      if (trackedAgentTasks.has(taskId)) return;
      trackedAgentTasks.set(taskId, {
        taskId,
        agentId: agentId || 'unknown',
        agentName: agentName || agentId || 'Agent',
        status: 'running',
        createdAt: new Date().toISOString(),
        completedAt: null,
        result: null,
        summary: null,
      });
      renderAgentTracker();
      log.agent('Tracking agent task', agentName || agentId, taskId);
    }

    function renderAgentTracker() {
      const tracker = document.getElementById('agentTracker');
      const cardList = document.getElementById('agentCardList');
      const dot = document.getElementById('agentTrackerDot');
      const countEl = document.getElementById('agentTrackerCount');
      if (!tracker || !cardList) return;
      const tasks = [...trackedAgentTasks.values()].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
      if (tasks.length === 0) { tracker.style.display = 'none'; return; }
      tracker.style.display = 'block';
      const running = tasks.filter(t => t.status === 'running' || t.status === 'pending');
      const done = tasks.filter(t => t.status === 'completed');
      const failed = tasks.filter(t => t.status === 'failed');
      if (dot) dot.style.display = running.length > 0 ? 'inline-block' : 'none';
      if (countEl) {
        const parts = [];
        if (running.length) parts.push(running.length + ' active');
        if (done.length) parts.push(done.length + ' done');
        if (failed.length) parts.push(failed.length + ' failed');
        countEl.textContent = parts.length ? '(' + parts.join(', ') + ')' : '';
      }
      cardList.innerHTML = tasks.map(t => {
        const statusClass = (t.status === 'running' || t.status === 'pending') ? 'running' : t.status;
        const statusLabel = t.status === 'running' ? '<span class="spinner"></span> Running' : t.status === 'pending' ? 'Queued' : t.status === 'completed' ? 'Done' : 'Failed';
        const elapsed = t.completedAt && t.createdAt ? Math.round((new Date(t.completedAt) - new Date(t.createdAt)) / 1000) : null;
        const timeStr = t.status === 'completed' && elapsed != null ? 'Completed in ' + elapsed + 's' : t.status === 'failed' ? 'Failed' : 'Started ' + new Date(t.createdAt).toLocaleTimeString();
        const summaryHtml = t.summary ? '<div class="agent-card-summary">' + escHtml(t.summary).slice(0, 300) + '</div>' : '';
        const hasResult = t.result != null;
        const toggleBtn = hasResult ? '<button type="button" class="agent-card-toggle" data-toggle-response>Show full response</button><div class="agent-card-body">' + escHtml(formatAgentResultFull(t.result)) + '</div>' : '';
        return '<div class="agent-card" data-task-id="' + t.taskId + '">'
          + '<div class="agent-card-header"><span class="agent-card-name">' + escHtml(t.agentName) + '</span><span class="agent-status-badge ' + statusClass + '">' + statusLabel + '</span></div>'
          + '<div class="agent-card-time">' + escHtml(timeStr) + '</div>'
          + summaryHtml
          + toggleBtn
          + '</div>';
      }).join('');
      cardList.querySelectorAll('[data-toggle-response]').forEach(btn => {
        btn.addEventListener('click', () => {
          const body = btn.nextElementSibling;
          if (!body) return;
          body.classList.toggle('open');
          btn.textContent = body.classList.contains('open') ? 'Hide full response' : 'Show full response';
        });
      });
    }

    async function pollAgentStatus() {
      if (!currentProjectId || !currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      try {
        const r = await authFetch(base + '/agents/tasks/list?projectId=' + encodeURIComponent(currentProjectId));
        if (!r.ok) return;
        const tasks = await r.json();
        let changed = false;
        for (const task of tasks) {
          const existing = trackedAgentTasks.get(task.taskId);
          if (existing) {
            if (existing.status !== task.status) {
              existing.status = task.status;
              existing.completedAt = task.completedAt || null;
              existing.result = task.result || null;
              existing.summary = task.result ? formatAgentResultSummary(task.result) : null;
              changed = true;
            }
          } else if (task.status === 'running' || task.status === 'pending') {
            trackedAgentTasks.set(task.taskId, {
              taskId: task.taskId,
              agentId: task.agentId,
              agentName: task.agentName || task.agentId,
              status: task.status,
              createdAt: task.createdAt,
              completedAt: null,
              result: null,
              summary: null,
            });
            changed = true;
          }
        }
        if (changed) renderAgentTracker();
      } catch (e) { log.agent('pollAgentStatus error', e); }
    }

    async function pollAgentResults() {
      await drainPatchQueue();
      if (!currentProjectId || !currentBackendUrl || !ws || ws.readyState !== WebSocket.OPEN) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      try {
        const r = await authFetch(base + '/agents/tasks/list?projectId=' + encodeURIComponent(currentProjectId) + '&status=completed');
        if (!r.ok) return;
        const tasks = await r.json();
        for (const task of tasks) {
          if (task.status !== 'completed' || deliveredTaskIds.has(task.taskId)) continue;
          deliveredTaskIds.add(task.taskId);
          const tracked = trackedAgentTasks.get(task.taskId);
          if (tracked) {
            tracked.status = 'completed';
            tracked.completedAt = task.completedAt;
            tracked.result = task.result;
            tracked.summary = formatAgentResultSummary(task.result);
          }
          renderAgentTracker();
          const summary = formatAgentResultSummary(task.result);
          const msg = '[System: Agent "' + (task.agentName || task.agentId) + '" has returned results. Here is a brief summary of the findings:\n' + summary + '\nPlease share a brief overview of these findings with the user and explain how they relate to the current idea refinement.]';
          ws.send(JSON.stringify({ clientContent: { turns: [{ role: 'user', parts: [{ text: msg }] }], turnComplete: true } }));
          log.agent('Injected agent result to conductor', task.agentName || task.agentId);
        }
      } catch (e) { log.agent('pollAgentResults error', e); }
      await pollAgentStatus();
    }

    function loadAgentTrackerForProject(projectId) {
      trackedAgentTasks.clear();
      if (!projectId || !currentBackendUrl) { renderAgentTracker(); return; }
      const base = currentBackendUrl.replace(/\/$/, '');
      authFetch(base + '/agents/tasks/list?projectId=' + encodeURIComponent(projectId))
        .then(r => r.ok ? r.json() : [])
        .then(tasks => {
          for (const t of tasks) {
            trackedAgentTasks.set(t.taskId, {
              taskId: t.taskId,
              agentId: t.agentId,
              agentName: t.agentName || t.agentId,
              status: t.status,
              createdAt: t.createdAt,
              completedAt: t.completedAt || null,
              result: t.result || null,
              summary: t.result ? formatAgentResultSummary(t.result) : null,
            });
            if (t.status === 'completed') deliveredTaskIds.add(t.taskId);
          }
          renderAgentTracker();
        })
        .catch(() => renderAgentTracker());
    }

    function normalizeForEchoMatch(s) {
      return (s || '')
        .trim()
        .replace(/\s+/g, ' ')
        .replace(/[.,!?;:'"]/g, '')
        .toLowerCase();
    }
    /** True if input looks like echoed model speech (full or partial match against recent model transcript). */
    function isLikelyEchoFromModel(inputText) {
      const normalized = normalizeForEchoMatch(inputText);
      if (normalized.length < ECHO_MATCH_MIN_LEN) return false;
      const recent = normalizeForEchoMatch(recentModelTranscript);
      if (recent.length === 0) return false;
      if (recent.includes(normalized) || normalized.includes(recent)) return true;
      for (let i = 0; i <= normalized.length - ECHO_MATCH_MIN_LEN; i++) {
        if (recent.includes(normalized.slice(i, i + ECHO_MATCH_MIN_LEN))) return true;
      }
      return false;
    }
    /** Remove embedded speaker prefixes so we don't double-label or show "YouModel*" in content. */
    function stripSpeakerPrefix(text, forUser) {
      let t = (text || '').trim();
      const prefixes = forUser
        ? [/^\s*Model\*?\s*/i, /^\s*Model\s+/i]
        : [/^\s*You\s*/i, /^\s*User\s*/i];
      for (const re of prefixes) {
        t = t.replace(re, '').trim();
      }
      return t;
    }

    function stripMarkers(text) {
      return text
        .replace(/---JSON---[\s\S]*?---JSON---/g, '')
        .replace(/---AGENT---[\s\S]*?---AGENT---/g, '')
        .replace(/\n{3,}/g, '\n\n')
        .trim();
    }

    function base64FromPCM(pcm16) {
      const u8 = new Uint8Array(pcm16.buffer, pcm16.byteOffset, pcm16.byteLength);
      let bin = '';
      const step = 8192;
      for (let i = 0; i < u8.length; i += step) {
        const slice = u8.subarray(i, Math.min(i + step, u8.length));
        bin += String.fromCharCode.apply(null, slice);
      }
      return btoa(bin);
    }

    function playPCM24k(base64Data) {
      try {
        const binary = atob(base64Data);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
        const samples = new Int16Array(bytes.buffer);
        if (!window.playbackCtx) {
          window.playbackCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: RECV_RATE });
          nextPlaybackTime = 0;
          log('playPCM24k: created playback AudioContext, state=', window.playbackCtx.state);
        }
        const ctx = window.playbackCtx;
        if (ctx.state === 'suspended') {
          ctx.resume().then(() => log('playPCM24k: context resumed')).catch(e => log('playPCM24k: resume failed', e));
        }
        const duration = samples.length / RECV_RATE;
        if (nextPlaybackTime < ctx.currentTime - 0.1) nextPlaybackTime = ctx.currentTime;
        const when = nextPlaybackTime;
        nextPlaybackTime += duration;
        const buf = ctx.createBuffer(1, samples.length, RECV_RATE);
        const ch = buf.getChannelData(0);
        for (let i = 0; i < samples.length; i++) ch[i] = samples[i] / 32768;
        const src = ctx.createBufferSource();
        src.buffer = buf;
        src.connect(ctx.destination);
        src.start(when);
      } catch (e) {
        log('playPCM24k ERROR', e);
      }
    }

    async function startConversation(apiKey, options = {}) {
      return new Promise((resolve, reject) => {
        const timeoutMs = 20000;
        let resolved = false;
        let messageCount = 0;
        const systemText = options.systemInstruction || 'You are a helpful voice assistant. Keep responses concise for conversation.';
        function finish(err) {
          if (resolved) return;
          resolved = true;
          log('finish()', err ? 'REJECT' : 'RESOLVE', err ? err.message : 'ok');
          if (err) reject(err); else resolve();
        }
        log('startConversation: timeoutMs=', timeoutMs);
        const t = setTimeout(() => {
          log('TIMEOUT fired after', timeoutMs, 'ms. Messages received so far:', messageCount);
          finish(new Error('Connection timeout. Check API key and that the Live API is enabled for your project.'));
        }, timeoutMs);

        if (ws) {
          log('startConversation: closing existing WebSocket to avoid duplicate handlers');
          ws.onmessage = null;
          ws.onopen = null;
          ws.onerror = null;
          ws.onclose = null;
          ws.close();
          ws = null;
        }

        window._liveFirstMessage = false;
        lastMessages.length = 0;
        if (debugStatsEl) debugStatsEl.textContent = 'Messages: 0';
        if (debugLastEl) debugLastEl.textContent = '';
        const url = LIVE_WS + '?key=' + encodeURIComponent(apiKey);
        const urlSafe = LIVE_WS + '?key=' + (apiKey ? apiKey.slice(0, 8) + '...' + apiKey.slice(-4) : 'MISSING');
        log('WebSocket URL (key redacted):', urlSafe);
        ws = new WebSocket(url);
        log('WebSocket created, readyState=', ws.readyState, '(CONNECTING=0)');

        ws.onopen = () => {
          log('ONOPEN: readyState=', ws.readyState, '(OPEN=1)');
          const setupPayload = {
            setup: {
              model: 'models/' + MODEL,
              generationConfig: { responseModalities: ['AUDIO'] },
              systemInstruction: { parts: [{ text: systemText }] },
              inputAudioTranscription: {},
              outputAudioTranscription: {}
            }
          };
          logPayload('SEND setup (first message):', setupPayload);
          const setupStr = JSON.stringify(setupPayload);
          ws.send(setupStr);
          log('SEND complete, byte length=', setupStr.length);
        };

        ws.onmessage = async (ev) => {
          messageCount++;
          let rawStr;
          if (typeof ev.data === 'string') rawStr = ev.data;
          else if (ev.data instanceof Blob) rawStr = await ev.data.text();
          else if (ev.data instanceof ArrayBuffer) rawStr = new TextDecoder().decode(ev.data);
          else rawStr = String(ev.data);
          const rawLen = rawStr.length;
          log('ONMESSAGE #' + messageCount, 'raw length=', rawLen, 'type=', typeof ev.data);

          let msg;
          try {
            msg = JSON.parse(rawStr);
          } catch (e) {
            log('ONMESSAGE parse ERROR', e);
            log('raw (first 500):', rawStr.slice(0, 500));
            return;
          }

          const topKeys = Object.keys(msg);
          log('ONMESSAGE #' + messageCount, 'top-level keys=', topKeys);
          pushDebug(messageCount, msg);

          if (messageCount <= 3 || 'setupComplete' in msg || 'setup_complete' in msg || 'error' in msg || topKeys.some(k => k.toLowerCase().includes('error'))) {
            logPayload('ONMESSAGE #' + messageCount + ' full payload:', msg);
          } else {
            log('ONMESSAGE #' + messageCount, '(payload):', JSON.stringify(stripForDebug(msg)).slice(0, 1200));
          }

          if (msg.setupComplete !== undefined || msg.setup_complete !== undefined) {
            log('SETUP COMPLETE received');
            setupDone = true;
            clearTimeout(t);
            finish();
            return;
          }
          if (msg.error) {
            log('ERROR in message:', msg.error);
            const errMsg = msg.error.message || msg.error.code || JSON.stringify(msg.error);
            clearTimeout(t);
            finish(new Error('API error: ' + errMsg));
            return;
          }

          const c = msg.serverContent || msg.server_content;
          const inputT = c ? (c.inputTranscription || c.input_transcription) : (msg.inputTranscription || msg.input_transcription);
          const outputT = c ? (c.outputTranscription || c.output_transcription) : (msg.outputTranscription || msg.output_transcription);
          const modelTurn = c ? (c.modelTurn || c.model_turn) : null;

          if (outputT?.text) {
            lastModelOutputTime = Date.now();
            log('outputTranscription:', outputT.text?.slice(0, 80));
            detectNewProjectFromModelOutput(outputT.text);
            const needsSpace = modelTurnTranscript.length > 0
              && !modelTurnTranscript.endsWith(' ')
              && !outputT.text.startsWith(' ');
            modelTranscriptBuffer += outputT.text;
            modelTurnTranscript += (needsSpace ? ' ' : '') + outputT.text;
            if (currentProjectId && currentBackendUrl) {
              tryApplyRegistryPatch(modelTranscriptBuffer, currentProjectId, currentBackendUrl);
              tryDispatchAgentTask(modelTranscriptBuffer, currentProjectId, currentBackendUrl);
            }
            recentModelTranscript += outputT.text;
            if (recentModelTranscript.length > RECENT_MODEL_TRANSCRIPT_MAX) {
              recentModelTranscript = recentModelTranscript.slice(-RECENT_MODEL_TRANSCRIPT_MAX);
            }
            if (modelFlushTimer) clearTimeout(modelFlushTimer);
            modelFlushTimer = setTimeout(flushModelTranscript, TRANSCRIPT_FLUSH_MS);
            if (sectionExtractTimer) {
              clearTimeout(sectionExtractTimer);
              sectionExtractTimer = setTimeout(() => {
                sectionExtractTimer = null;
                if (modelTurnTranscript && currentProjectId && currentBackendUrl) {
                  tryExtractSectionContent(modelTurnTranscript, currentProjectId, currentBackendUrl);
                  modelTurnTranscript = '';
                }
              }, SECTION_EXTRACT_DEBOUNCE_MS);
            }
          }
          if (inputT?.text) {
            const now = Date.now();
            const inTimeWindow = now - lastModelOutputTime < ECHO_SUPPRESS_MS;
            const matchesModel = isLikelyEchoFromModel(inputT.text);
            const currentRms = micLevel.rms || 0;
            const userSpeakingLoud = currentRms > ECHO_GATE_RMS_THRESHOLD;
            // Content match always suppresses (it's definitely echo)
            // Time window only suppresses if mic level is low (likely echo, not real speech)
            if (matchesModel) {
              log.echo('inputTranscription SUPPRESSED reason=content-match', inputT.text?.slice(0, 80));
            } else if (inTimeWindow && !userSpeakingLoud) {
              log.echo('inputTranscription SUPPRESSED reason=time-window (low rms=' + currentRms.toFixed(4) + ')', inputT.text?.slice(0, 80));
            } else {
              if (inTimeWindow && userSpeakingLoud) {
                log.echo('inputTranscription ALLOWED despite time-window (high rms=' + currentRms.toFixed(4) + ')', inputT.text?.slice(0, 80));
              }
              log.mic('inputTranscription:', inputT.text?.slice(0, 80));
              detectNewProjectVoiceCommand(inputT.text);
              userTranscriptBuffer += inputT.text;
              if (userFlushTimer) clearTimeout(userFlushTimer);
              userFlushTimer = setTimeout(flushUserTranscript, TRANSCRIPT_FLUSH_MS);
            }
          }
          const parts = modelTurn?.parts;
          if (parts && Array.isArray(parts)) {
            const seen = new Set();
            for (const part of parts) {
              const inline = part.inlineData || part.inline_data;
              const data = inline?.data;
              const mime = inline?.mimeType || inline?.mime_type || '';
              if (data && mime.startsWith('audio/')) {
                if (seen.has(data)) continue;
                seen.add(data);
                lastModelOutputTime = Date.now();
                modelIsSpeaking = true;
                const numSamples = atob(data).length / 2;
                const durationMs = (numSamples / RECV_RATE) * 1000;
                log.audio('playing chunk b64len=' + data?.length + ' durationMs=' + Math.round(durationMs) + ' queuedMs=' + Math.round(Math.max(0, (nextPlaybackTime - (window.playbackCtx?.currentTime || 0)) * 1000)));
                playPCM24k(data);
                scheduleModelSpeakingEnd(durationMs);
              }
            }
          }
          const generationComplete = c ? (c.generationComplete || c.generation_complete) : false;
          if (generationComplete) {
            // Schedule end based on remaining queued audio, then reset
            const ctx = window.playbackCtx;
            const remainingMs = ctx
              ? Math.max(0, (nextPlaybackTime - ctx.currentTime) * 1000)
              : 0;
            if (modelSpeakingEndTimer) clearTimeout(modelSpeakingEndTimer);
            modelSpeakingEndTimer = setTimeout(() => {
              modelSpeakingEndTimer = null;
              modelIsSpeaking = false;
              nextPlaybackTime = 0;
              lastModelSpeakingEndTime = Date.now();
              log.state('modelIsSpeaking = false (generation complete + playback drained)');
            }, remainingMs + 600);
            if (modelTranscriptBuffer && currentProjectId && currentBackendUrl) {
              tryApplyRegistryPatch(modelTranscriptBuffer, currentProjectId, currentBackendUrl);
              tryDispatchAgentTask(modelTranscriptBuffer, currentProjectId, currentBackendUrl);
              tryExtractFromSpeech(modelTranscriptBuffer, currentProjectId, currentBackendUrl);
            }
            if (modelTurnTranscript && currentProjectId && currentBackendUrl) {
              if (sectionExtractTimer) clearTimeout(sectionExtractTimer);
              sectionExtractTimer = setTimeout(() => {
                sectionExtractTimer = null;
                if (modelTurnTranscript && currentProjectId && currentBackendUrl) {
                  tryExtractSectionContent(modelTurnTranscript, currentProjectId, currentBackendUrl);
                  modelTurnTranscript = '';
                }
              }, SECTION_EXTRACT_DEBOUNCE_MS);
            }
          }
          if (c && !inputT?.text && !outputT?.text && (!parts || !parts.length)) {
            log('serverContent but no transcript/audio:', Object.keys(c));
          } else if (!c && !msg.setupComplete && msg.setup_complete === undefined && topKeys.length > 0) {
            log('Message not serverContent/setupComplete, keys=', topKeys);
          }
        };

        ws.onerror = (e) => {
          log.ws('ONERROR:', e);
          log.ws('ONERROR type:', e?.type, 'target:', e?.target?.readyState);
          clearTimeout(t);
          finish(new Error('WebSocket error'));
        };

        ws.onclose = (ev) => {
          log.ws('ONCLOSE: code=', ev.code, 'reason=', ev.reason, 'wasClean=', ev.wasClean);
          log.ws('ONCLOSE full event:', { code: ev.code, reason: ev.reason, wasClean: ev.wasClean });
          clearTimeout(t);
          if (!setupDone && ev.code !== 1000) {
            finish(new Error('Connection closed: ' + (ev.reason || ev.code)));
            return;
          }
          if (setupDone && !userInitiatedClose && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
            attemptReconnect();
          }
        };
      });
    }

    async function attemptReconnect() {
      reconnectAttempts++;
      const delayMs = Math.min(2000 * Math.pow(2, reconnectAttempts - 1), 8000);
      log('Connection lost. Reconnecting in', delayMs, 'ms (attempt', reconnectAttempts + '/' + MAX_RECONNECT_ATTEMPTS + ')');
      setStatus('Connection lost. Reconnecting…', 'error');
      await new Promise(r => setTimeout(r, delayMs));
      if (userInitiatedClose) return;
      if (!lastConversationConfig) {
        log('Cannot reconnect: no saved config');
        setStatus('Connection lost', 'error');
        return;
      }
      try {
        const cfg = lastConversationConfig;
        await startConversation(cfg.apiKey, {
          systemInstruction: cfg.systemInstruction,
          projectId: cfg.projectId,
          backendUrl: cfg.backendUrl,
        });
        if (ws && ws.readyState === WebSocket.OPEN) {
          flushUserTranscript();
          flushModelTranscript();
          const ctx = buildReconnectContext();
          if (ctx) {
            const turns = [];
            const merged = mergeConsecutiveTranscript(conversationLog);
            const MAX_HISTORY = 30;
            const recent = merged.length > MAX_HISTORY ? merged.slice(-MAX_HISTORY) : merged;
            for (const entry of recent) {
              turns.push({ role: entry.speaker === 'user' ? 'user' : 'model', parts: [{ text: entry.text }] });
            }
            turns.push({ role: 'user', parts: [{ text: '[System: The connection was interrupted. This is a reconnected session with the conversation history above. Continue EXACTLY where we left off. Do NOT start over, re-introduce yourself, or repeat questions already asked. ProjectId: ' + (currentProjectId || 'unknown') + ']' }] });
            ws.send(JSON.stringify({ clientContent: { turns, turnComplete: true } }));
            log('Reconnect: sent ' + (turns.length - 1) + ' history turns + resume instruction');
          } else {
            ws.send(JSON.stringify({ clientContent: { turns: [{ role: 'user', parts: [{ text: '[System: Connection was briefly interrupted. Continue the conversation. ProjectId: ' + (currentProjectId || 'unknown') + ']' }] }], turnComplete: true } }));
          }
          await startMic(ws);
          if (currentProjectId && currentBackendUrl && !agentResultsPollInterval) {
            agentResultsPollInterval = setInterval(pollAgentResults, AGENT_RESULTS_POLL_MS);
          }
          reconnectAttempts = 0;
          setStatus('Reconnected – conversation resumed', 'active');
          log('Reconnection successful');
        }
      } catch (e) {
        log('Reconnection failed:', e.message);
        if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS && !userInitiatedClose) {
          attemptReconnect();
        } else {
          setStatus('Connection lost. Click Stop then Start to retry.', 'error');
        }
      }
    }

    async function startMic(ws) {
      const micSelect = document.getElementById('micSelect');
      const preferredDeviceId = micSelect ? micSelect.value : '';
      const audioConstraints = {
        channelCount: 1,
        sampleRate: SEND_RATE,
        autoGainControl: true,
        echoCancellation: true,
        noiseSuppression: true
      };
      if (preferredDeviceId) audioConstraints.deviceId = { exact: preferredDeviceId };
      log('startMic: requesting getUserMedia', preferredDeviceId ? 'deviceId=' + preferredDeviceId.slice(0, 20) + '...' : 'default');
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
      const audioTracks = mediaStream.getAudioTracks();
      const micTrack = audioTracks[0];
      const deviceLabel = micTrack ? micTrack.label || 'Unknown device' : 'No audio track';
      const deviceId = micTrack && micTrack.getSettings ? micTrack.getSettings().deviceId : null;
      log('startMic: got MediaStream tracks=', mediaStream.getTracks().length, 'device:', deviceLabel, deviceId ? 'id=' + deviceId.slice(0, 20) + '...' : '');
      const deviceEl = document.getElementById('micDevice');
      if (deviceEl) deviceEl.textContent = 'Microphone: ' + deviceLabel + (deviceId ? ' · id: ' + deviceId.slice(0, 16) + (deviceId.length > 16 ? '…' : '') : '');
      const ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SEND_RATE });
      audioContext = ctx;
      log('startMic: AudioContext state=', ctx.state, 'sampleRate=', ctx.sampleRate);
      if (ctx.state === 'suspended') {
        await ctx.resume();
        log('startMic: AudioContext resumed, state=', ctx.state);
      }
      const src = ctx.createMediaStreamSource(mediaStream);
      const analyser = ctx.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = 0.1;
      micLevel.analyser = analyser;
      const rate = ctx.sampleRate;
      log('startMic: using AudioWorklet, rate=', rate);
      const SILENCE_MS = 1000;
      const VOLUME_THRESHOLD = 0.003;
      let silenceStart = null;
      let lastWasSpeaking = false;
      let didLogSpeaking = false;
      let audioChunkCount = 0;
      let lastAudioLog = 0;
      await ctx.audioWorklet.addModule('mic-processor.js');
      const workletNode = new AudioWorkletNode(ctx, 'mic-processor', { numberOfInputs: 1, numberOfOutputs: 1 });
      workletNode.port.onmessage = (e) => {
        const { samples, rms } = e.data || {};
        if (samples == null) return;
        const speaking = rms > VOLUME_THRESHOLD;
        micLevel.rms = rms;
        micLevel.speaking = speaking;
        micLevel.ticks = (micLevel.ticks || 0) + 1;
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        if (modelIsSpeaking) return;
        const now = Date.now();
        const inGrace = lastModelSpeakingEndTime && (now - lastModelSpeakingEndTime < POST_SPEECH_GRACE_MS);
        if (speaking) {
          silenceStart = null;
          lastWasSpeaking = true;
          if (!didLogSpeaking) {
            didLogSpeaking = true;
            log.mic('speech detected rms=' + rms.toFixed(4) + ', silence timer will start when you stop');
          }
        } else {
          if (lastWasSpeaking) {
            if (silenceStart === null) silenceStart = now;
            else if (now - silenceStart >= SILENCE_MS) {
              log.mic('silence detected ' + Math.round((now - silenceStart) / 1000) + 's, sending audioStreamEnd');
              ws.send(JSON.stringify({ realtimeInput: { audioStreamEnd: true } }));
              silenceStart = null;
              lastWasSpeaking = false;
            }
          }
        }
        // During grace period, allow loud speech through (energy gate) — only block quiet echo-level input
        if (inGrace && rms > ECHO_GATE_RMS_THRESHOLD) {
          log.echo('grace-period override: rms=' + rms.toFixed(4) + ' above gate threshold, treating as real speech');
        } else if (inGrace || !speaking) {
          return;
        }
        const pcm16 = new Int16Array(samples.length);
        for (let i = 0; i < samples.length; i++) {
          const s = Math.max(-1, Math.min(1, samples[i]));
          pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
        }
        let data = pcm16;
        if (rate !== SEND_RATE) {
          const ratio = rate / SEND_RATE;
          const outLen = Math.floor(pcm16.length / ratio);
          const out = new Int16Array(outLen);
          for (let i = 0; i < outLen; i++) out[i] = pcm16[Math.floor(i * ratio)];
          data = out;
        }
        const b64 = base64FromPCM(data);
        ws.send(JSON.stringify({ realtimeInput: { audio: { mimeType: 'audio/pcm;rate=16000', data: b64 } } }));
        audioChunkCount++;
        if (audioChunkCount === 1) log('startMic: first realtime audio chunk sent, base64 length=', b64.length);
        else if (now - lastAudioLog >= 5000) {
          log('startMic: realtime audio chunks sent so far=', audioChunkCount);
          lastAudioLog = now;
        }
      };
      src.connect(workletNode);
      workletNode.connect(ctx.destination);
      src.connect(analyser);
      processor = workletNode;
      const meterEl = document.getElementById('micMeter');
      const barEl = document.getElementById('micBar');
      const valueEl = document.getElementById('micValue');
      if (meterEl) meterEl.style.display = 'block';
      const timeData = new Uint8Array(analyser.fftSize);
      micMeterInterval = setInterval(() => {
        let r = micLevel.rms;
        if (micLevel.analyser) {
          micLevel.analyser.getByteTimeDomainData(timeData);
          let sum = 0;
          for (let i = 0; i < timeData.length; i++) {
            const n = (timeData[i] - 128) / 128;
            sum += n * n;
          }
          r = Math.sqrt(sum / timeData.length);
          micLevel.rms = r;
          micLevel.speaking = r > VOLUME_THRESHOLD;
        }
        const rSafe = Math.max(r, 1e-6);
        const pct = Math.min(100, Math.max(0, Math.round(100 * Math.log1p(rSafe * 50) / Math.log1p(50))));
        if (barEl) {
          barEl.style.width = pct + '%';
          barEl.classList.toggle('speaking', micLevel.speaking);
          barEl.setAttribute('aria-valuenow', pct);
        }
        if (valueEl) valueEl.textContent = 'RMS: ' + r.toFixed(4) + (micLevel.speaking ? ' · Speaking' : ' · Silence') + ' · ticks: ' + (micLevel.ticks || 0);
      }, 50);
      log('startMic: AudioWorklet connected, mic active');
    }

    function stopAll() {
      log('stopAll: clearing processor, mediaStream, ws');
      userInitiatedClose = true;
      if (sectionExtractTimer) {
        clearTimeout(sectionExtractTimer);
        sectionExtractTimer = null;
        if (modelTurnTranscript && currentProjectId && currentBackendUrl) {
          tryExtractSectionContent(modelTurnTranscript, currentProjectId, currentBackendUrl);
          modelTurnTranscript = '';
        }
      }
      drainPatchQueue().catch(() => {});
      if (window.Android) try { window.Android.stopSession(); } catch(_) {}
      if (agentResultsPollInterval) {
        clearInterval(agentResultsPollInterval);
        agentResultsPollInterval = null;
      }
      if (modelSpeakingEndTimer) {
        clearTimeout(modelSpeakingEndTimer);
        modelSpeakingEndTimer = null;
      }
      modelIsSpeaking = false;
      flushUserTranscript();
      flushModelTranscript();
      modelTurnTranscript = '';
      if (currentProjectId && currentBackendUrl) {
        const pid = currentProjectId;
        const burl = currentBackendUrl;
        const saveAndPolish = async () => {
          try {
            if (conversationLog.length > lastTranscriptSaveLen) {
              const base = burl.replace(/\/$/, '');
              await authFetch(base + '/projects/' + encodeURIComponent(pid), {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ conversationTranscript: conversationLog, _refinementNote: 'conversation transcript', _refinementSource: 'voice' })
              });
              lastTranscriptSaveLen = conversationLog.length;
              log('Saved conversation transcript (' + conversationLog.length + ' entries)');
            }
            await triggerDocumentPolisher(pid, burl, 'session end');
          } catch (e) { log('stopAll: save/polish error', e); }
        };
        saveAndPolish();
      }
      if (micMeterInterval) {
        clearInterval(micMeterInterval);
        micMeterInterval = null;
      }
      micLevel.rms = 0;
      micLevel.speaking = false;
      micLevel.ticks = 0;
      micLevel.analyser = null;
      const meterEl = document.getElementById('micMeter');
      if (meterEl) meterEl.style.display = 'none';
      if (processor && audioContext) {
        try { processor.disconnect(); } catch (err) { log('stopAll: processor.disconnect error', err); }
      }
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
      if (ws) {
        log('stopAll: closing WebSocket');
        ws.close();
        ws = null;
      }
      setupDone = false;
      log('stopAll: done');
    }

    btnStart.addEventListener('click', async () => {
      log('===== Start conversation clicked =====');
      hideError();
      let apiKey;
      let backendUrl = '';
      let conductorPrompt = '';
      let projectId = null;
      let resumableProject = null;
      try {
        let primaryUrl = '', fallbackUrl = '';
        if (window.VOICE_AGENT_CONFIG) {
          apiKey = window.VOICE_AGENT_CONFIG.GEMINI_API_KEY;
          primaryUrl = (window.VOICE_AGENT_CONFIG.BACKEND_URL || '').trim();
          fallbackUrl = (window.VOICE_AGENT_CONFIG.FALLBACK_URL || '').trim();
          if (window.VOICE_AGENT_CONFIG.API_KEY) currentApiKey = window.VOICE_AGENT_CONFIG.API_KEY;
          log('Config loaded from native bridge');
        } else {
          const mod = await import('./config.js');
          apiKey = mod.GEMINI_API_KEY;
          primaryUrl = (mod.BACKEND_URL || '').trim();
          fallbackUrl = (mod.FALLBACK_URL || '').trim();
          if (mod.API_KEY) currentApiKey = mod.API_KEY;
        }
        backendUrl = await resolveBackendUrl(primaryUrl, fallbackUrl);
        log('Config ready, API key length=', apiKey?.length ?? 0, 'backendUrl=', backendUrl ? 'set' : 'none', 'auth=', currentApiKey ? 'yes' : 'no');
      } catch (e) {
        log('Config load FAILED', e);
        configWarning.hidden = false;
        setStatus('Missing config.js');
        return;
      }
      configWarning.hidden = true;
      if (!apiKey || apiKey === 'YOUR_API_KEY_HERE' || apiKey === 'YOUR_GEMINI_API_KEY') {
        log('API key missing or placeholder');
        configWarning.hidden = false;
        configWarning.textContent = 'Edit config.js and set GEMINI_API_KEY (get one at https://aistudio.google.com/apikey).';
        setStatus('Set API key');
        return;
      }
      if (backendUrl) {
        const base = backendUrl.replace(/\/$/, '');
        try {
          const lastId = localStorage.getItem('idearefinement_lastProjectId');
          if (lastId) {
            const r = await authFetch(base + '/projects/' + encodeURIComponent(lastId));
            if (r.ok) resumableProject = await r.json();
          }
          if (resumableProject?.checkpoint) {
            projectId = resumableProject.projectId;
            currentProjectId = projectId;
            currentBackendUrl = base;
            updateScreenLayer(resumableProject);
            document.getElementById('screenLayer').style.display = 'block';
            loadAgentTrackerForProject(projectId);
            await showProjectsSection();
            log('Resuming project', projectId);
          } else {
            const createRes = await authFetch(base + '/projects', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
            const ct = createRes.headers.get('content-type') || '';
            if (ct.includes('text/html')) {
              log('Backend returned HTML — is BACKEND_URL the backend (port 3002), not the web app (3001)?');
              configWarning.hidden = false;
              configWarning.textContent = 'Backend returned a page instead of JSON. In config.js set BACKEND_URL to http://localhost:3002 (the backend), not 3001.';
            } else if (createRes.ok) {
              const proj = await createRes.json();
              projectId = proj.projectId;
              currentProjectId = projectId;
              currentBackendUrl = base;
              updateScreenLayer(proj);
              document.getElementById('screenLayer').style.display = 'block';
              loadAgentTrackerForProject(proj.projectId);
              await showProjectsSection();
              log('Created project', projectId);
            }
          }
          const promptRes = await authFetch(base + '/prompts/conductor');
          if (promptRes.ok) conductorPrompt = await promptRes.text();
          if (conductorPrompt && base) {
            const listRes = await authFetch(base + '/projects');
            const projectList = listRes.ok ? await listRes.json() : [];
            const currentName = (resumableProject?.name || (projectId && projectList.find(p => p.projectId === projectId)?.name) || '').trim();
            const listStr = projectList.map(p => (p.name || '(no name)') + ' (' + p.projectId + ')').join(', ');
            conductorPrompt = conductorPrompt + '\n\nCurrent projectId: ' + (projectId || 'unknown') + (currentName ? '\nCurrent project name: ' + currentName : '') + '\nExisting projects (use these names when user says "work on X"): ' + (listStr || 'none');
            let fullProject = resumableProject;
            if (projectId && !fullProject) {
              try {
                const r = await authFetch(base + '/projects/' + encodeURIComponent(projectId));
                if (r.ok) fullProject = await r.json();
              } catch (_) {}
            }
            if (fullProject && (fullProject.snapshot || fullProject.name || fullProject.mvp || (fullProject.openQuestions && fullProject.openQuestions.length > 0))) {
              const s = fullProject;
              const stateLines = [
                'Current project state (use to answer "what\'s the gist?" or "what were we refining?"):',
                'Name: ' + (s.name || '(none)'),
                'Snapshot: ' + (s.snapshot || '(none)'),
                'Track: ' + (s.track || '') + ', Rigor: ' + (s.rigor || ''),
                'Phase: ' + (s.phase || 1),
                (s.mvp ? 'MVP: ' + s.mvp : ''),
                (s.nonGoals ? 'Non-goals: ' + s.nonGoals : ''),
                (s.decisions && s.decisions.length) ? 'Decisions: ' + s.decisions.join('; ') : '',
                (s.openQuestions && s.openQuestions.length) ? 'Open questions: ' + s.openQuestions.join('; ') : '',
                (s.nextActions && s.nextActions.length) ? 'Next actions: ' + s.nextActions.join('; ') : '',
                (s.validationPlan && s.validationPlan.trim()) ? 'Validation plan: ' + String(s.validationPlan).trim().slice(0, 200) : '',
                (s.buildPlan && s.buildPlan.trim()) ? 'Build plan: ' + String(s.buildPlan).trim().slice(0, 200) : '',
                (s.agentResults && s.agentResults.length) ? 'Recent agent results: ' + s.agentResults.slice(-3).map(ar => (ar.agentName || ar.agentId) + ': ' + (typeof ar.result === 'object' && ar.result && ar.result.note ? ar.result.note : JSON.stringify(ar.result).slice(0, 150))).join(' | ') : ''
              ].filter(Boolean);
              conductorPrompt = conductorPrompt + '\n\n' + stateLines.join('\n');
            }
            const agentsRes = await authFetch(base + '/agents');
            if (agentsRes.ok) {
              const agentsList = await agentsRes.json();
              if (agentsList.length) {
                conductorPrompt = conductorPrompt + '\n\nAvailable agents (output ---AGENT--- agentId | task description ---AGENT--- to delegate):\n' + agentsList.map(a => a.agentId + ' - ' + (a.name || a.agentId) + ': ' + (a.description || '')).join('\n');
              }
            }
          }
        } catch (e) {
          log('Backend setup failed', e);
          configWarning.hidden = false;
          configWarning.textContent = 'Could not reach backend at ' + backendUrl + '. Start the backend (cd backend && npm start) or check BACKEND_URL in config.js.';
        }
      }
      const systemInstruction = conductorPrompt || undefined;
      setStatus('Connecting…');
      btnStart.disabled = true;
      userInitiatedClose = false;
      reconnectAttempts = 0;
      lastConversationConfig = { apiKey, systemInstruction, projectId, backendUrl: currentBackendUrl };
      try {
        log('Calling startConversation(apiKey, options)...');
        await startConversation(apiKey, { systemInstruction, projectId, backendUrl: currentBackendUrl });
        log('startConversation resolved, sending initial turn to wake model');
        setStatus('Starting…');
        const projForResume = projectId && resumableProject ? resumableProject : null;
        const initialText = projForResume?.checkpoint
          ? 'We are resuming project ' + projectId + '. Checkpoint: ' + (projForResume.checkpoint.note || 'paused') + '. Open questions: ' + (projForResume.openQuestions?.length || 0) + '. Ask one restart question.'
          : projectId
            ? 'We are starting idea refinement. ProjectId is ' + projectId + '. Say a brief hello and ask for the idea in one sentence.'
            : 'Hello. The user is ready. Say a brief hello and that you are listening.';
        ws.send(JSON.stringify({
          clientContent: {
            turns: [{ role: 'user', parts: [{ text: initialText }] }],
            turnComplete: true
          }
        }));
        log('Initial clientContent sent');
        setStatus('Starting microphone…');
        if (!window.playbackCtx) {
          window.playbackCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: RECV_RATE });
          log('Pre-created playback AudioContext, state=', window.playbackCtx.state);
          if (window.playbackCtx.state === 'suspended') {
            window.playbackCtx.resume().then(() => log('Playback context resumed')).catch(e => log('Resume failed', e));
          }
        }
        await startMic(ws);
        if (window.Android) try { window.Android.startSession(); } catch(_) {}
        if (currentProjectId && currentBackendUrl) {
          deliveredTaskIds.clear();
          loadAgentTrackerForProject(currentProjectId);
          agentResultsPollInterval = setInterval(pollAgentResults, AGENT_RESULTS_POLL_MS);
        }
        setStatus('In conversation – speak then click "Done speaking" or wait 1s silence', 'active');
        btnStart.style.display = 'none';
        btnStop.style.display = 'block';
        document.getElementById('btnDoneSpeaking').style.display = 'block';
        log('===== Conversation started successfully =====');
      } catch (e) {
        log('startConversation or startMic FAILED', e?.message ?? e);
        showError(e.message || String(e));
        stopAll();
      }
      btnStart.disabled = false;
    });

    document.getElementById('btnNewIdea').addEventListener('click', () => {
      localStorage.removeItem('idearefinement_lastProjectId');
      document.getElementById('btnNewIdea').style.display = 'none';
      setStatus('Ready. Click Start for a new idea.');
      log('Cleared resumable session');
    });

    btnStop.addEventListener('click', async () => {
      log('===== Stop clicked =====');
      if (currentProjectId && currentBackendUrl) {
        const base = currentBackendUrl.replace(/\/$/, '');
        try {
          const proj = await fetchProject(base, currentProjectId);
          if (proj) {
            const checkpoint = { at: new Date().toISOString(), note: 'Paused by user', openQuestions: proj.openQuestions || [], nextActions: proj.nextActions || [] };
            await authFetch(base + '/projects/' + encodeURIComponent(currentProjectId), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ checkpoint }) });
            localStorage.setItem('idearefinement_lastProjectId', currentProjectId);
            log('Checkpoint saved', currentProjectId);
          }
        } catch (e) { log('Checkpoint save failed', e); }
      }
      stopAll();
      btnStop.style.display = 'none';
        btnStart.style.display = 'block';
        document.getElementById('btnDoneSpeaking').style.display = 'none';
      document.getElementById('btnNewIdea').style.display = 'block';
      setStatus('Stopped. Session saved — click Start to resume or New idea to start fresh.');
    });

    document.getElementById('btnDoneSpeaking').addEventListener('click', () => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        log('Done speaking (button): sending audioStreamEnd');
        ws.send(JSON.stringify({ realtimeInput: { audioStreamEnd: true } }));
      }
    });

    document.getElementById('btnCopyDebug').addEventListener('click', () => {
      const filter = _activeLogFilter;
      const entries = filter ? sessionLog.filter(e => e.cat === filter) : sessionLog;
      const text = entries.map(e => `[${e.ts}] [${e.cat.toUpperCase()}] ${e.msg}`).join('\n');
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById('btnCopyDebug');
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy'; }, 1500);
      }).catch(e => log('Copy failed', e));
    });

    document.getElementById('btnDownloadLog').addEventListener('click', _downloadSessionLog);

    document.getElementById('logFilter').addEventListener('change', (e) => {
      _activeLogFilter = e.target.value;
      _renderLogPanel();
    });

    document.getElementById('workerButtons')?.addEventListener('click', (e) => {
      const job = e.target?.closest('.worker-btn')?.getAttribute('data-job');
      if (job) runWorker(job);
    });

    document.getElementById('screenLayer')?.addEventListener('click', (e) => {
      if (!e.target.classList?.contains('screen-project-name')) return;
      const span = e.target;
      const projectId = span.dataset.projectId;
      if (!projectId || !currentBackendUrl) return;
      const currentName = (span.textContent === 'Click to add name' ? '' : span.textContent).trim();
      const inp = document.createElement('input');
      inp.type = 'text';
      inp.value = currentName;
      inp.placeholder = 'Project name';
      inp.style.cssText = 'background:#1e293b;color:#e2e8f0;border:1px solid #334155;border-radius:4px;padding:2px 6px;font-size:0.875rem;min-width:120px;';
      span.textContent = '';
      span.appendChild(inp);
      inp.focus();
      function saveName() {
        const name = inp.value.trim();
        span.removeChild(inp);
        span.textContent = name || 'Click to add name';
        span.dataset.projectId = projectId;
        if (!name) return;
        const base = currentBackendUrl.replace(/\/$/, '');
        authFetch(base + '/projects/' + encodeURIComponent(projectId), { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name }) })
          .then(r => r.ok ? r.json() : null)
          .then(proj => { if (proj) { updateScreenLayer(proj); refreshProjectsList(); } });
      }
      inp.addEventListener('blur', saveName);
      inp.addEventListener('keydown', (ev) => { if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); } });
    });

    document.getElementById('btnRefreshProjects')?.addEventListener('click', () => refreshProjectsList());
    document.getElementById('btnNewProject')?.addEventListener('click', async () => {
      if (!currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const btn = document.getElementById('btnNewProject');
      if (btn) btn.disabled = true;
      try {
        const createRes = await authFetch(base + '/projects', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: '{}' });
        if (!createRes.ok) { log('New project creation failed', createRes.status); return; }
        const proj = await createRes.json();
        currentProjectId = proj.projectId;
        localStorage.setItem('idearefinement_lastProjectId', proj.projectId);
        updateScreenLayer(proj);
        document.getElementById('screenLayer').style.display = 'block';
        loadAgentTrackerForProject(proj.projectId);
        await refreshProjectsList();
        syncProjectsSelectToCurrent();
        log('Created new project', proj.projectId);
        setStatus('New project created. Click Start to begin refining.');
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ clientContent: { turns: [{ role: 'user', parts: [{ text: '[System: User switched to a brand new project. ProjectId is ' + proj.projectId + '. Say a brief hello and ask for their new idea.]' }] }], turnComplete: true } }));
        }
      } catch (e) { log('New project creation error', e); }
      if (btn) btn.disabled = false;
    });
    document.getElementById('btnFrameworkLoad')?.addEventListener('click', () => loadFramework());
    document.getElementById('btnFrameworkSave')?.addEventListener('click', () => saveFramework());
    document.getElementById('btnDownloadRefinements')?.addEventListener('click', () => downloadRefinementsMd());
    document.getElementById('btnStructureIdea')?.addEventListener('click', async () => {
      if (!currentProjectId || !currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const btn = document.getElementById('btnStructureIdea');
      const origText = btn.textContent;
      btn.textContent = 'Structuring...';
      btn.disabled = true;
      btn.style.opacity = '0.6';
      try {
        const transcriptLines = [];
        document.querySelectorAll('#transcript .line').forEach(el => {
          const label = el.querySelector('.label')?.textContent?.trim() || '';
          const text = el.textContent.replace(label, '').trim();
          if (text) transcriptLines.push((label ? label + ' ' : '') + text);
        });
        const transcript = transcriptLines.join('\n');
        const r = await authFetch(base + '/projects/' + encodeURIComponent(currentProjectId) + '/structure', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ transcript }) });
        if (r.ok) {
          const project = await r.json();
          updateScreenLayer(project);
          await refreshProjectsList();
          syncProjectsSelectToCurrent();
          log('Document structured successfully');
          btn.textContent = 'Structured!';
          btn.style.background = '#22c55e';
          setTimeout(() => { btn.textContent = origText; btn.style.background = '#f59e0b'; }, 3000);
        } else {
          const err = await r.json().catch(() => ({}));
          log('Structure failed', r.status, err.error);
          btn.textContent = 'Failed';
          btn.style.background = '#ef4444';
          setTimeout(() => { btn.textContent = origText; btn.style.background = '#f59e0b'; }, 3000);
        }
      } catch (e) {
        log('Structure error', e);
        btn.textContent = 'Error';
        setTimeout(() => { btn.textContent = origText; btn.style.background = '#f59e0b'; }, 3000);
      } finally {
        btn.disabled = false;
        btn.style.opacity = '1';
      }
    });
    document.getElementById('btnExportIdea')?.addEventListener('click', async () => {
      if (!currentProjectId || !currentBackendUrl) return;
      const base = currentBackendUrl.replace(/\/$/, '');
      const btn = document.getElementById('btnExportIdea');
      const origText = btn.textContent;
      btn.textContent = 'Structuring & exporting...';
      btn.disabled = true;
      try {
        const transcriptLines = [];
        document.querySelectorAll('#transcript .line').forEach(el => {
          const label = el.querySelector('.label')?.textContent?.trim() || '';
          const text = el.textContent.replace(label, '').trim();
          if (text) transcriptLines.push((label ? label + ' ' : '') + text);
        });
        const transcript = transcriptLines.join('\n');
        if (transcript.length > 50) {
          await authFetch(base + '/projects/' + encodeURIComponent(currentProjectId) + '/structure', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ transcript }) });
        }
        const r = await authFetch(base + '/projects/' + encodeURIComponent(currentProjectId) + '/export');
        if (!r.ok) { log('Export failed', r.status); return; }
        const blob = await r.blob();
        const disp = r.headers.get('Content-Disposition') || '';
        const fnMatch = disp.match(/filename="?([^"]+)"?/);
        const filename = fnMatch ? fnMatch[1] : 'REFINED_IDEA.md';
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
        log('Exported refined idea');
      } catch (e) { log('Export error', e); }
      finally { btn.textContent = origText; btn.disabled = false; }
    });
    document.getElementById('btnAddRefinement')?.addEventListener('click', () => addManualRefinement());
    document.getElementById('btnRefreshRefinements')?.addEventListener('click', async () => {
      if (!currentProjectId || !currentBackendUrl) return;
      const proj = await fetchProject(currentBackendUrl.replace(/\/$/, ''), currentProjectId);
      if (proj) renderRefinements(proj.refinements);
    });
    document.getElementById('projectsSelect')?.addEventListener('change', (e) => {
      const id = e.target?.value;
      if (id) loadProjectIntoUI(id);
    });

    (async () => {
      try {
        let primaryUrl, fallbackUrl, authKey;
        if (window.VOICE_AGENT_CONFIG) {
          primaryUrl = (window.VOICE_AGENT_CONFIG.BACKEND_URL || '').trim();
          fallbackUrl = (window.VOICE_AGENT_CONFIG.FALLBACK_URL || '').trim();
          authKey = window.VOICE_AGENT_CONFIG.API_KEY;
        } else {
          const mod = await import('./config.js');
          primaryUrl = (mod.BACKEND_URL || '').trim();
          fallbackUrl = (mod.FALLBACK_URL || '').trim();
          authKey = mod.API_KEY;
        }
        if (authKey) currentApiKey = authKey;
        const url = await resolveBackendUrl(primaryUrl, fallbackUrl);
        if (url) { currentBackendUrl = url.replace(/\/$/, ''); showProjectsSection(); }
      } catch (_) {}
    })();
  </script>
</body>
</html>
